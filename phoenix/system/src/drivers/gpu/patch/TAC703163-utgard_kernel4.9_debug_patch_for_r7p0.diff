diff -Naur driver/src/devicedrv/mali/common/mali_executor.c driver/src/devicedrv/mali/common/mali_executor.c
--- driver/src/devicedrv/mali/common/mali_executor.c	2017-01-20 14:42:05.000000000 +0800
+++ driver/src/devicedrv/mali/common/mali_executor.c	2017-04-27 18:55:11.000000000 +0800
@@ -463,7 +463,7 @@
 			if (NULL != pp_job) {
 				/* PP job completed, make sure it is freed */
 				mali_scheduler_complete_pp_job(pp_job, 0,
-							       MALI_FALSE, MALI_TRUE);
+							       MALI_TRUE, MALI_TRUE);
 			}
 		}
 	}
@@ -481,7 +481,7 @@
 				if (NULL != pp_job) {
 					/* PP job completed, free it */
 					mali_scheduler_complete_pp_job(pp_job,
-								       0, MALI_FALSE,
+								       0, MALI_TRUE,
 								       MALI_TRUE);
 				}
 			}
@@ -986,7 +986,7 @@
 
 			/* GP job completed, make sure it is freed */
 			mali_scheduler_complete_gp_job(gp_job, MALI_FALSE,
-						       MALI_FALSE, MALI_TRUE);
+						       MALI_TRUE, MALI_TRUE);
 		} else {
 			/* Same session, but not working, so just clear it */
 			mali_group_clear_session(gp_group);
@@ -1003,7 +1003,7 @@
 			if (NULL != pp_job) {
 				/* PP job completed, make sure it is freed */
 				mali_scheduler_complete_pp_job(pp_job, 0,
-							       MALI_FALSE, MALI_TRUE);
+							       MALI_TRUE, MALI_TRUE);
 			}
 		}
 	}
@@ -1018,7 +1018,7 @@
 			if (NULL != pp_job) {
 				/* PP job completed, make sure it is freed */
 				mali_scheduler_complete_pp_job(pp_job, 0,
-							       MALI_FALSE, MALI_TRUE);
+							       MALI_TRUE, MALI_TRUE);
 			}
 		}
 	}
diff -Naur driver/src/devicedrv/mali/common/mali_gp_job.c driver/src/devicedrv/mali/common/mali_gp_job.c
--- driver/src/devicedrv/mali/common/mali_gp_job.c	2017-01-20 14:42:05.000000000 +0800
+++ driver/src/devicedrv/mali/common/mali_gp_job.c	2017-04-27 18:55:11.000000000 +0800
@@ -133,7 +133,7 @@
 				goto fail1;
 			}
 
-			memory_list = (u32 __user *)(uintptr_t)uargs->deferred_mem_list;
+			memory_list = (u32 __user *)(uintptr_t)job->uargs.deferred_mem_list;
 
 			if (0 != _mali_osk_copy_from_user(job->varying_list, memory_list, sizeof(u32) * job->uargs.deferred_mem_num)) {
 				MALI_PRINT_ERROR(("Mali GP job: Failed to copy varying list from user space!\n"));
diff -Naur driver/src/devicedrv/mali/common/mali_kernel_core.c driver/src/devicedrv/mali/common/mali_kernel_core.c
--- driver/src/devicedrv/mali/common/mali_kernel_core.c	2017-01-20 14:42:04.000000000 +0800
+++ driver/src/devicedrv/mali/common/mali_kernel_core.c	2017-09-04 10:16:02.226482722 +0800
@@ -44,8 +44,12 @@
 #include <linux/sched.h>
 #include <linux/atomic.h>
 #if defined(CONFIG_MALI_DMA_BUF_FENCE)
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(4, 10, 0)
+#include <linux/dma-fence.h>
+#else
 #include <linux/fence.h>
 #endif
+#endif
 
 #define MALI_SHARED_MEMORY_DEFAULT_SIZE 0xffffffff
 
@@ -752,7 +756,11 @@
 
 	mali_pp_job_initialize();
 
-	mali_timeline_initialize();
+	err = mali_timeline_initialize();
+	if (_MALI_OSK_ERR_OK != err) {
+		mali_terminate_subsystems();
+		return err;
+	}
 
 	err = mali_session_initialize();
 	if (_MALI_OSK_ERR_OK != err) {
@@ -1161,7 +1169,9 @@
 
 	/* Initialize the dma fence context.*/
 #if defined(CONFIG_MALI_DMA_BUF_FENCE)
-#if LINUX_VERSION_CODE >= KERNEL_VERSION(3, 17, 0)
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(4, 10, 0)
+	session->fence_context = dma_fence_context_alloc(1);
+#elif LINUX_VERSION_CODE >= KERNEL_VERSION(3, 17, 0)
 	session->fence_context = fence_context_alloc(1);
 	_mali_osk_atomic_init(&session->fence_seqno, 0);
 #else
diff -Naur driver/src/devicedrv/mali/common/mali_pp_job.h driver/src/devicedrv/mali/common/mali_pp_job.h
--- driver/src/devicedrv/mali/common/mali_pp_job.h	2017-01-20 14:42:05.000000000 +0800
+++ driver/src/devicedrv/mali/common/mali_pp_job.h	2017-09-04 10:16:02.226482722 +0800
@@ -27,7 +27,6 @@
 #endif
 #if defined(CONFIG_MALI_DMA_BUF_FENCE)
 #include "linux/mali_dma_fence.h"
-#include <linux/fence.h>
 #endif
 
 typedef enum pp_job_status {
@@ -102,8 +101,12 @@
 
 #if defined(CONFIG_MALI_DMA_BUF_FENCE)
 	struct mali_dma_fence_context dma_fence_context; /**< The mali dma fence context to record dma fence waiters that this job wait for */
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(4, 10, 0)
+	struct dma_fence *rendered_dma_fence; /**< the new dma fence link to this job */
+#else
 	struct fence *rendered_dma_fence; /**< the new dma fence link to this job */
 #endif
+#endif
 };
 
 void mali_pp_job_initialize(void);
diff -Naur driver/src/devicedrv/mali/common/mali_scheduler.c driver/src/devicedrv/mali/common/mali_scheduler.c
--- driver/src/devicedrv/mali/common/mali_scheduler.c	2017-01-20 14:42:05.000000000 +0800
+++ driver/src/devicedrv/mali/common/mali_scheduler.c	2017-04-27 18:55:11.000000000 +0800
@@ -713,7 +713,7 @@
 		mali_gp_job_signal_pp_tracker(gp_job, MALI_FALSE);
 		_mali_osk_list_delinit(&gp_job->list);
 		mali_scheduler_complete_gp_job(gp_job,
-					       MALI_FALSE, MALI_FALSE, MALI_TRUE);
+					       MALI_FALSE, MALI_TRUE, MALI_TRUE);
 	}
 
 	/* Release and complete non-running PP jobs */
@@ -722,7 +722,7 @@
 		mali_timeline_tracker_release(mali_pp_job_get_tracker(pp_job));
 		_mali_osk_list_delinit(&pp_job->list);
 		mali_scheduler_complete_pp_job(pp_job, 0,
-					       MALI_FALSE, MALI_TRUE);
+					       MALI_TRUE, MALI_TRUE);
 	}
 }
 
diff -Naur driver/src/devicedrv/mali/common/mali_soft_job.c driver/src/devicedrv/mali/common/mali_soft_job.c
--- driver/src/devicedrv/mali/common/mali_soft_job.c	2017-01-20 14:42:05.000000000 +0800
+++ driver/src/devicedrv/mali/common/mali_soft_job.c	2017-04-27 18:55:11.000000000 +0800
@@ -1,7 +1,7 @@
 /*
  * This confidential and proprietary software may be used only as
  * authorised by a licensing agreement from ARM Limited
- * (C) COPYRIGHT 2013-2014, 2016-2017 ARM Limited
+ * (C) COPYRIGHT 2013-2014, 2017 ARM Limited
  * ALL RIGHTS RESERVED
  * The entire notice above must be reproduced on all authorised
  * copies and copies may only be made to the extent permitted
@@ -435,4 +435,6 @@
 
 		mali_soft_job_destroy(job);
 	}
+
+	mali_executor_schedule_from_mask(MALI_SCHEDULER_MASK_ALL, MALI_FALSE);
 }
diff -Naur driver/src/devicedrv/mali/common/mali_timeline.c driver/src/devicedrv/mali/common/mali_timeline.c
--- driver/src/devicedrv/mali/common/mali_timeline.c	2017-01-20 14:42:05.000000000 +0800
+++ driver/src/devicedrv/mali/common/mali_timeline.c	2017-09-04 10:16:02.230482648 +0800
@@ -7,7 +7,7 @@
  * copies and copies may only be made to the extent permitted
  * by a licensing agreement from ARM Limited.
  */
-
+#include <linux/file.h>
 #include "mali_timeline.h"
 #include "mali_kernel_common.h"
 #include "mali_scheduler.h"
@@ -19,6 +19,12 @@
 
 #define MALI_TIMELINE_SYSTEM_LOCKED(system) (mali_spinlock_reentrant_is_held((system)->spinlock, _mali_osk_get_tid()))
 
+#if defined(CONFIG_SYNC) || defined(CONFIG_SYNC_FILE)
+_mali_osk_wq_work_t *sync_fence_callback_work_t = NULL;
+_mali_osk_spinlock_irq_t *sync_fence_callback_list_lock = NULL;
+static _MALI_OSK_LIST_HEAD_STATIC_INIT(sync_fence_callback_queue);
+#endif
+
 /*
  * Following three elements are used to record how many
  * gp, physical pp or virtual pp jobs are delayed in the whole
@@ -32,7 +38,7 @@
 static mali_scheduler_mask mali_timeline_system_release_waiter(struct mali_timeline_system *system,
 		struct mali_timeline_waiter *waiter);
 
-#if defined(CONFIG_SYNC)
+#if defined(CONFIG_SYNC) || defined(CONFIG_SYNC_FILE)
 #include <linux/version.h>
 #if LINUX_VERSION_CODE < KERNEL_VERSION(3,5,0)
 #include <linux/list.h>
@@ -68,88 +74,27 @@
 #endif /* LINUX_VERSION_CODE < KERNEL_VERSION(3,5,0) */
 
 /* Callback that is called when a sync fence a tracker is waiting on is signaled. */
+#if LINUX_VERSION_CODE < KERNEL_VERSION(4, 6, 0)
 static void mali_timeline_sync_fence_callback(struct sync_fence *sync_fence, struct sync_fence_waiter *sync_fence_waiter)
-{
-	struct mali_timeline_system  *system;
-	struct mali_timeline_waiter  *waiter;
-	struct mali_timeline_tracker *tracker;
-	mali_scheduler_mask schedule_mask = MALI_SCHEDULER_MASK_EMPTY;
-	u32 tid = _mali_osk_get_tid();
-	mali_bool is_aborting = MALI_FALSE;
-#if LINUX_VERSION_CODE < KERNEL_VERSION(3, 17, 0)
-	int fence_status = sync_fence->status;
 #else
-	int fence_status = atomic_read(&sync_fence->status);
+static void mali_timeline_sync_fence_callback(struct mali_internal_sync_fence *sync_fence, struct mali_internal_sync_fence_waiter *sync_fence_waiter)
 #endif
+{
+	struct mali_timeline_tracker *tracker;
 
-	MALI_DEBUG_ASSERT_POINTER(sync_fence);
+	MALI_IGNORE(sync_fence);
 	MALI_DEBUG_ASSERT_POINTER(sync_fence_waiter);
 
 	tracker = _MALI_OSK_CONTAINER_OF(sync_fence_waiter, struct mali_timeline_tracker, sync_fence_waiter);
 	MALI_DEBUG_ASSERT_POINTER(tracker);
 
-	system = tracker->system;
-	MALI_DEBUG_ASSERT_POINTER(system);
-	MALI_DEBUG_ASSERT_POINTER(system->session);
-
-	mali_spinlock_reentrant_wait(system->spinlock, tid);
-
-	is_aborting = system->session->is_aborting;
-	if (!is_aborting && (0 > fence_status)) {
-		MALI_PRINT_ERROR(("Mali Timeline: sync fence fd %d signaled with error %d\n", tracker->fence.sync_fd, fence_status));
-		tracker->activation_error |= MALI_TIMELINE_ACTIVATION_ERROR_SYNC_BIT;
-	}
-
-	waiter = tracker->waiter_sync;
-	MALI_DEBUG_ASSERT_POINTER(waiter);
-
-	tracker->sync_fence = NULL;
-	tracker->fence.sync_fd = -1;
-
-	schedule_mask |= mali_timeline_system_release_waiter(system, waiter);
-
-	/* If aborting, wake up sleepers that are waiting for sync fence callbacks to complete. */
-	if (is_aborting) {
-		_mali_osk_wait_queue_wake_up(system->wait_queue);
-	}
-
-	mali_spinlock_reentrant_signal(system->spinlock, tid);
-
-	/*
-	 * Older versions of Linux, before 3.5, doesn't support fput() in interrupt
-	 * context. For those older kernels, allocate a list object and put the
-	 * fence object on that and defer the call to sync_fence_put() to a workqueue.
-	 */
-#if LINUX_VERSION_CODE < KERNEL_VERSION(3,5,0)
-	{
-		struct mali_deferred_fence_put_entry *obj;
-
-		obj = kzalloc(sizeof(struct mali_deferred_fence_put_entry), GFP_ATOMIC);
-		if (obj) {
-			unsigned long flags;
-			mali_bool schedule = MALI_FALSE;
-
-			obj->fence = sync_fence;
-
-			spin_lock_irqsave(&mali_timeline_sync_fence_to_free_lock, flags);
-			if (hlist_empty(&mali_timeline_sync_fence_to_free_list))
-				schedule = MALI_TRUE;
-			hlist_add_head(&obj->list, &mali_timeline_sync_fence_to_free_list);
-			spin_unlock_irqrestore(&mali_timeline_sync_fence_to_free_lock, flags);
-
-			if (schedule)
-				schedule_delayed_work(&delayed_sync_fence_put, 0);
-		}
-	}
-#else
-	sync_fence_put(sync_fence);
-#endif /* LINUX_VERSION_CODE < KERNEL_VERSION(3,5,0) */
+	_mali_osk_spinlock_irq_lock(sync_fence_callback_list_lock);
+	_mali_osk_list_addtail(&tracker->sync_fence_signal_list, &sync_fence_callback_queue);
+	_mali_osk_spinlock_irq_unlock(sync_fence_callback_list_lock);
 
-	if (!is_aborting) {
-		mali_executor_schedule_from_mask(schedule_mask, MALI_TRUE);
-	}
+	_mali_osk_wq_schedule_work(sync_fence_callback_work_t);
 }
-#endif /* defined(CONFIG_SYNC) */
+#endif /* defined(CONFIG_SYNC) || defined(CONFIG_SYNC_FILE) */
 
 static mali_scheduler_mask mali_timeline_tracker_time_out(struct mali_timeline_tracker *tracker)
 {
@@ -242,15 +187,17 @@
 			_mali_osk_wq_delayed_delete_work_nonflush(timeline->delayed_work);
 		}
 
-#if defined(CONFIG_SYNC)
+#if defined(CONFIG_SYNC) || defined(CONFIG_SYNC_FILE)
 		if (NULL != timeline->sync_tl) {
+#if LINUX_VERSION_CODE < KERNEL_VERSION(4, 6, 0)
 			sync_timeline_destroy(timeline->sync_tl);
+#else
+			mali_internal_sync_timeline_destroy(timeline->sync_tl);
+#endif
 		}
-#endif /* defined(CONFIG_SYNC) */
-
-#ifndef CONFIG_SYNC
+#else
 		_mali_osk_free(timeline);
-#endif
+#endif /* defined(CONFIG_SYNC) || defined(CONFIG_SYNC_FILE) */
 	}
 }
 
@@ -288,7 +235,7 @@
 
 	timeline->timer_active = MALI_FALSE;
 
-#if defined(CONFIG_SYNC)
+#if defined(CONFIG_SYNC) || defined(CONFIG_SYNC_FILE)
 	{
 		char timeline_name[32];
 
@@ -322,7 +269,7 @@
 			return NULL;
 		}
 	}
-#endif /* defined(CONFIG_SYNC) */
+#endif /* defined(CONFIG_SYNC) || defined(CONFIG_SYNC_FILE) */
 
 	return timeline;
 }
@@ -679,11 +626,11 @@
 		mali_timeline_fence_wait_activate((struct mali_timeline_fence_wait_tracker *) tracker->job);
 		break;
 	case MALI_TIMELINE_TRACKER_SYNC:
-#if defined(CONFIG_SYNC)
+#if defined(CONFIG_SYNC) || defined(CONFIG_SYNC_FILE)
 		mali_timeline_sync_fence_activate((struct mali_timeline_sync_fence_tracker *) tracker->job);
 #else
 		MALI_PRINT_ERROR(("Mali Timeline: sync tracker not supported\n", tracker->type));
-#endif /* defined(CONFIG_SYNC) */
+#endif /* defined(CONFIG_SYNC) || defined(CONFIG_SYNC_FILE) */
 		break;
 	default:
 		MALI_PRINT_ERROR(("Mali Timeline - Illegal tracker type: %d\n", tracker->type));
@@ -774,13 +721,13 @@
 		}
 	}
 
-#if defined(CONFIG_SYNC)
+#if defined(CONFIG_SYNC) || defined(CONFIG_SYNC_FILE)
 	system->signaled_sync_tl = mali_sync_timeline_create(NULL, "mali-always-signaled");
 	if (NULL == system->signaled_sync_tl) {
 		mali_timeline_system_destroy(system);
 		return NULL;
 	}
-#endif /* defined(CONFIG_SYNC) */
+#endif /* defined(CONFIG_SYNC) || defined(CONFIG_SYNC_FILE) */
 
 	system->waiter_empty_list = NULL;
 	system->session = session;
@@ -795,7 +742,7 @@
 	return system;
 }
 
-#if defined(CONFIG_MALI_DMA_BUF_FENCE) ||defined(CONFIG_SYNC)
+#if defined(CONFIG_MALI_DMA_BUF_FENCE) ||defined(CONFIG_SYNC) ||defined(CONFIG_SYNC_FILE)
 /**
  * Check if there are any trackers left on timeline.
  *
@@ -812,7 +759,7 @@
 
 	return mali_timeline_is_empty(timeline);
 }
-#if defined(CONFIG_SYNC)
+#if defined(CONFIG_SYNC) ||defined(CONFIG_SYNC_FILE)
 /**
  * Cancel sync fence waiters waited upon by trackers on all timelines.
  *
@@ -849,7 +796,11 @@
 			MALI_DEBUG_PRINT(3, ("Mali Timeline: Cancelling sync fence wait for tracker 0x%08X.\n", tracker));
 
 			/* Cancel sync fence waiter. */
+#if LINUX_VERSION_CODE < KERNEL_VERSION(4, 6, 0)
 			if (0 == sync_fence_cancel_async(tracker->sync_fence, &tracker->sync_fence_waiter)) {
+#else
+			if (0 == mali_internal_sync_fence_cancel_async(tracker->sync_fence, &tracker->sync_fence_waiter)) {
+#endif
 				/* Callback was not called, move tracker to local list. */
 				_mali_osk_list_add(&tracker->sync_fence_cancel_list, &tracker_list);
 			}
@@ -873,7 +824,7 @@
 	}
 }
 
-#endif /* defined(CONFIG_SYNC) */
+#endif /* defined(CONFIG_SYNC) || defined(CONFIG_SYNC_FILE) */
 
 #if defined(CONFIG_MALI_DMA_BUF_FENCE)
 static void mali_timeline_cancel_dma_fence_waiters(struct mali_timeline_system *system)
@@ -913,8 +864,14 @@
 				* This function returns true if the callback is successfully removed,
 				* or false if the fence has already been signaled.
 				*/
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(4, 10, 0)
+				bool ret = dma_fence_remove_callback(pp_job->dma_fence_context.mali_dma_fence_waiters[j]->fence,
+								     &pp_job->dma_fence_context.mali_dma_fence_waiters[j]->base);
+
+#else
 				bool ret = fence_remove_callback(pp_job->dma_fence_context.mali_dma_fence_waiters[j]->fence,
 								 &pp_job->dma_fence_context.mali_dma_fence_waiters[j]->base);
+#endif
 				if (ret) {
 					fence_is_signaled = MALI_FALSE;
 				}
@@ -952,9 +909,9 @@
 
 	MALI_DEBUG_PRINT(3, ("Mali Timeline: Aborting timeline system for session 0x%08X.\n", system->session));
 
-#if defined(CONFIG_SYNC)
+#if defined(CONFIG_SYNC) || defined(CONFIG_SYNC_FILE)
 	mali_timeline_cancel_sync_fence_waiters(system);
-#endif /* defined(CONFIG_SYNC) */
+#endif /* defined(CONFIG_SYNC) || defined(CONFIG_SYNC_FILE) */
 
 #if defined(CONFIG_MALI_DMA_BUF_FENCE)
 	mali_timeline_cancel_dma_fence_waiters(system);
@@ -982,7 +939,7 @@
 {
 	u32 i;
 	struct mali_timeline_waiter *waiter, *next;
-#if defined(CONFIG_SYNC)
+#if defined(CONFIG_SYNC) || defined(CONFIG_SYNC_FILE)
 	u32 tid = _mali_osk_get_tid();
 #endif
 
@@ -1007,9 +964,13 @@
 			waiter = next;
 		}
 
-#if defined(CONFIG_SYNC)
+#if defined(CONFIG_SYNC) || defined(CONFIG_SYNC_FILE)
 		if (NULL != system->signaled_sync_tl) {
+#if LINUX_VERSION_CODE < KERNEL_VERSION(4, 6, 0)
 			sync_timeline_destroy(system->signaled_sync_tl);
+#else
+			mali_internal_sync_timeline_destroy(system->signaled_sync_tl);
+#endif
 		}
 
 		for (i = 0; i < MALI_TIMELINE_MAX; ++i) {
@@ -1019,7 +980,7 @@
 				mali_spinlock_reentrant_signal(system->timelines[i]->spinlock, tid);
 			}
 		}
-#endif /* defined(CONFIG_SYNC) */
+#endif /* defined(CONFIG_SYNC) || defined(CONFIG_SYNC_FILE) */
 
 		for (i = 0; i < MALI_TIMELINE_MAX; ++i) {
 			if (NULL != system->timelines[i]) {
@@ -1053,9 +1014,9 @@
 		}
 	}
 
-#if defined(CONFIG_SYNC)
+#if defined(CONFIG_SYNC) || defined(CONFIG_SYNC_FILE)
 	if (-1 != fence->sync_fd) ++num_waiters;
-#endif /* defined(CONFIG_SYNC) */
+#endif /* defined(CONFIG_SYNC) || defined(CONFIG_SYNC_FILE) */
 
 	return num_waiters;
 }
@@ -1140,9 +1101,13 @@
 	int i;
 	u32 tid = _mali_osk_get_tid();
 	mali_scheduler_mask schedule_mask = MALI_SCHEDULER_MASK_EMPTY;
-#if defined(CONFIG_SYNC)
+#if defined(CONFIG_SYNC) || defined(CONFIG_SYNC_FILE)
+#if LINUX_VERSION_CODE < KERNEL_VERSION(4, 6, 0)
 	struct sync_fence *sync_fence = NULL;
-#endif /* defined(CONFIG_SYNC) */
+#else
+	struct mali_internal_sync_fence *sync_fence = NULL;
+#endif
+#endif /* defined(CONFIG_SYNC) || defined(CONFIG_SYNC_FILE) */
 
 	MALI_DEBUG_ASSERT_POINTER(system);
 	MALI_DEBUG_ASSERT_POINTER(tracker);
@@ -1214,12 +1179,15 @@
 		/* Add waiter to timeline. */
 		mali_timeline_insert_waiter(timeline, waiter);
 	}
-#if defined(CONFIG_SYNC)
+#if defined(CONFIG_SYNC) || defined(CONFIG_SYNC_FILE)
 	if (-1 != tracker->fence.sync_fd) {
 		int ret;
 		struct mali_timeline_waiter *waiter;
-
+#if LINUX_VERSION_CODE < KERNEL_VERSION(4, 6, 0)
 		sync_fence = sync_fence_fdget(tracker->fence.sync_fd);
+#else
+		sync_fence = mali_internal_sync_fence_fdget(tracker->fence.sync_fd);
+#endif
 		if (unlikely(NULL == sync_fence)) {
 			MALI_PRINT_ERROR(("Mali Timeline: failed to get sync fence from fd %d\n", tracker->fence.sync_fd));
 			goto exit;
@@ -1232,8 +1200,13 @@
 		}
 
 		/* Start asynchronous wait that will release waiter when the fence is signaled. */
+#if LINUX_VERSION_CODE < KERNEL_VERSION(4, 6, 0)
 		sync_fence_waiter_init(&tracker->sync_fence_waiter, mali_timeline_sync_fence_callback);
 		ret = sync_fence_wait_async(sync_fence, &tracker->sync_fence_waiter);
+#else
+		mali_internal_sync_fence_waiter_init(&tracker->sync_fence_waiter, mali_timeline_sync_fence_callback);
+		ret = mali_internal_sync_fence_wait_async(sync_fence, &tracker->sync_fence_waiter);
+#endif
 		if (1 == ret) {
 			/* Fence already signaled, no waiter needed. */
 			tracker->fence.sync_fd = -1;
@@ -1272,7 +1245,7 @@
 
 		sync_fence = NULL;
 	}
-#endif /* defined(CONFIG_SYNC)*/
+#endif /* defined(CONFIG_SYNC) || defined(CONFIG_SYNC_FILE)*/
 #if defined(CONFIG_MALI_DMA_BUF_FENCE)
 	if ((NULL != tracker->timeline) && (MALI_TIMELINE_PP == tracker->timeline->id)) {
 
@@ -1312,9 +1285,9 @@
 	}
 #endif /* defined(CONFIG_MALI_DMA_BUF_FENCE)*/
 
-#if defined(CONFIG_MALI_DMA_BUF_FENCE) ||defined(CONFIG_SYNC)
+#if defined(CONFIG_MALI_DMA_BUF_FENCE) ||defined(CONFIG_SYNC) || defined(CONFIG_SYNC_FILE)
 exit:
-#endif /* defined(CONFIG_MALI_DMA_BUF_FENCE) || defined(CONFIG_SYNC) */
+#endif /* defined(CONFIG_MALI_DMA_BUF_FENCE) || defined(CONFIG_SYNC) || defined(CONFIG_SYNC_FILE) */
 
 	if (NULL != waiter_tail) {
 		mali_timeline_system_release_waiter_list(system, waiter_tail, waiter_head);
@@ -1330,11 +1303,15 @@
 
 	mali_spinlock_reentrant_signal(system->spinlock, tid);
 
-#if defined(CONFIG_SYNC)
+#if defined(CONFIG_SYNC) || defined(CONFIG_SYNC_FILE)
 	if (NULL != sync_fence) {
+#if LINUX_VERSION_CODE < KERNEL_VERSION(4, 6, 0)
 		sync_fence_put(sync_fence);
+#else
+		fput(sync_fence->file);
+#endif
 	}
-#endif /* defined(CONFIG_SYNC) */
+#endif /* defined(CONFIG_SYNC) || defined(CONFIG_SYNC_FILE) */
 
 	mali_executor_schedule_from_mask(schedule_mask, MALI_FALSE);
 }
@@ -1467,18 +1444,158 @@
 	return point;
 }
 
-void mali_timeline_initialize(void)
+#if defined(CONFIG_SYNC) || defined(CONFIG_SYNC_FILE)
+static void mali_timeline_do_sync_fence_callback(void *arg)
+{
+	_MALI_OSK_LIST_HEAD_STATIC_INIT(list);
+	struct mali_timeline_tracker *tracker;
+	struct mali_timeline_tracker *tmp_tracker;
+	u32 tid = _mali_osk_get_tid();
+
+	MALI_IGNORE(arg);
+
+	/*
+	 * Quickly "unhook" the jobs pending to be deleted, so we can release
+	 * the lock before we start deleting the job objects
+	 * (without any locks held)
+	 */
+	_mali_osk_spinlock_irq_lock(sync_fence_callback_list_lock);
+	_mali_osk_list_move_list(&sync_fence_callback_queue, &list);
+	_mali_osk_spinlock_irq_unlock(sync_fence_callback_list_lock);
+
+	_MALI_OSK_LIST_FOREACHENTRY(tracker, tmp_tracker, &list,
+				    struct mali_timeline_tracker, sync_fence_signal_list) {
+		mali_scheduler_mask schedule_mask = MALI_SCHEDULER_MASK_EMPTY;
+		mali_bool is_aborting = MALI_FALSE;
+		int fence_status = 0;
+#if LINUX_VERSION_CODE < KERNEL_VERSION(4, 6, 0)
+		struct sync_fence *sync_fence = NULL;
+#else
+		struct mali_internal_sync_fence *sync_fence = NULL;
+#endif
+		struct mali_timeline_system  *system = NULL;
+		struct mali_timeline_waiter  *waiter = NULL;
+
+		_mali_osk_list_delinit(&tracker->sync_fence_signal_list);
+
+		sync_fence = tracker->sync_fence;
+		MALI_DEBUG_ASSERT_POINTER(sync_fence);
+
+#if LINUX_VERSION_CODE < KERNEL_VERSION(3, 17, 0)
+		fence_status = sync_fence->status;
+#elif LINUX_VERSION_CODE < KERNEL_VERSION(4, 9, 0)
+		fence_status = atomic_read(&sync_fence->status);
+#else
+		fence_status = sync_fence->fence->ops->signaled(sync_fence->fence);
+#endif
+
+		system = tracker->system;
+		MALI_DEBUG_ASSERT_POINTER(system);
+		MALI_DEBUG_ASSERT_POINTER(system->session);
+
+		mali_spinlock_reentrant_wait(system->spinlock, tid);
+
+		is_aborting = system->session->is_aborting;
+		if (!is_aborting && (0 > fence_status)) {
+			MALI_PRINT_ERROR(("Mali Timeline: sync fence fd %d signaled with error %d\n", tracker->fence.sync_fd, fence_status));
+			tracker->activation_error |= MALI_TIMELINE_ACTIVATION_ERROR_SYNC_BIT;
+		}
+
+		waiter = tracker->waiter_sync;
+		MALI_DEBUG_ASSERT_POINTER(waiter);
+
+		tracker->sync_fence = NULL;
+		tracker->fence.sync_fd = -1;
+
+		schedule_mask |= mali_timeline_system_release_waiter(system, waiter);
+
+		/* If aborting, wake up sleepers that are waiting for sync fence callbacks to complete. */
+		if (is_aborting) {
+			_mali_osk_wait_queue_wake_up(system->wait_queue);
+		}
+
+		mali_spinlock_reentrant_signal(system->spinlock, tid);
+
+		/*
+		 * Older versions of Linux, before 3.5, doesn't support fput() in interrupt
+		 * context. For those older kernels, allocate a list object and put the
+		 * fence object on that and defer the call to sync_fence_put() to a workqueue.
+		 */
+#if LINUX_VERSION_CODE < KERNEL_VERSION(3,5,0)
+		{
+			struct mali_deferred_fence_put_entry *obj;
+
+			obj = kzalloc(sizeof(struct mali_deferred_fence_put_entry), GFP_ATOMIC);
+			if (obj) {
+				unsigned long flags;
+				mali_bool schedule = MALI_FALSE;
+
+				obj->fence = sync_fence;
+
+				spin_lock_irqsave(&mali_timeline_sync_fence_to_free_lock, flags);
+				if (hlist_empty(&mali_timeline_sync_fence_to_free_list))
+					schedule = MALI_TRUE;
+				hlist_add_head(&obj->list, &mali_timeline_sync_fence_to_free_list);
+				spin_unlock_irqrestore(&mali_timeline_sync_fence_to_free_lock, flags);
+
+				if (schedule)
+					schedule_delayed_work(&delayed_sync_fence_put, 0);
+			}
+		}
+#else
+#if LINUX_VERSION_CODE < KERNEL_VERSION(4, 6, 0)
+		sync_fence_put(sync_fence);
+#else
+		fput(sync_fence->file);
+#endif
+#endif /* LINUX_VERSION_CODE < KERNEL_VERSION(3,5,0) */
+
+		if (!is_aborting) {
+			mali_executor_schedule_from_mask(schedule_mask, MALI_TRUE);
+		}
+	}
+}
+#endif
+_mali_osk_errcode_t mali_timeline_initialize(void)
 {
 	_mali_osk_atomic_init(&gp_tracker_count, 0);
 	_mali_osk_atomic_init(&phy_pp_tracker_count, 0);
 	_mali_osk_atomic_init(&virt_pp_tracker_count, 0);
+
+#if defined(CONFIG_SYNC) || defined(CONFIG_SYNC_FILE)
+	sync_fence_callback_list_lock = _mali_osk_spinlock_irq_init(_MALI_OSK_LOCKFLAG_UNORDERED, _MALI_OSK_LOCK_ORDER_FIRST);
+	if (NULL == sync_fence_callback_list_lock) {
+		return _MALI_OSK_ERR_NOMEM;
+	}
+
+	sync_fence_callback_work_t = _mali_osk_wq_create_work(
+					     mali_timeline_do_sync_fence_callback, NULL);
+
+	if (NULL == sync_fence_callback_work_t) {
+		return _MALI_OSK_ERR_FAULT;
+	}
+#endif
+	return _MALI_OSK_ERR_OK;
 }
 
+
 void mali_timeline_terminate(void)
 {
 	_mali_osk_atomic_term(&gp_tracker_count);
 	_mali_osk_atomic_term(&phy_pp_tracker_count);
 	_mali_osk_atomic_term(&virt_pp_tracker_count);
+
+#if defined(CONFIG_SYNC) || defined(CONFIG_SYNC_FILE)
+	if (NULL != sync_fence_callback_list_lock) {
+		_mali_osk_spinlock_irq_term(sync_fence_callback_list_lock);
+		sync_fence_callback_list_lock = NULL;
+	}
+
+	if (NULL != sync_fence_callback_work_t) {
+		_mali_osk_wq_delete_work(sync_fence_callback_work_t);
+		sync_fence_callback_work_t = NULL;
+	}
+#endif
 }
 
 #if defined(MALI_TIMELINE_DEBUG_FUNCTIONS)
@@ -1573,31 +1690,59 @@
 	state_char = *(tracker_state + mali_timeline_debug_get_tracker_state(tracker));
 	_mali_osk_snprintf(tracker_type, sizeof(tracker_type), "%s", timeline_tracker_type_to_string(tracker->type));
 
-#if defined(CONFIG_SYNC)
+#if defined(CONFIG_SYNC) || defined(CONFIG_SYNC_FILE)
 	if (0 != tracker->trigger_ref_count) {
-		_mali_osk_ctxprintf(print_ctx, "TL:  %s %u %c - ref_wait:%u [%s(%u),%s(%u),%s(%u), fd:%d, fence:(0x%08X)]  job:(0x%08X)\n",
-				    tracker_type, tracker->point, state_char, tracker->trigger_ref_count,
-				    is_waiting_on_timeline(tracker, MALI_TIMELINE_GP) ? "WaitGP" : " ", tracker->fence.points[0],
-				    is_waiting_on_timeline(tracker, MALI_TIMELINE_PP) ? "WaitPP" : " ", tracker->fence.points[1],
-				    is_waiting_on_timeline(tracker, MALI_TIMELINE_SOFT) ? "WaitSOFT" : " ", tracker->fence.points[2],
-				    tracker->fence.sync_fd, (unsigned int)(uintptr_t)(tracker->sync_fence), (unsigned int)(uintptr_t)(tracker->job));
+		if (print_ctx)
+			_mali_osk_ctxprintf(print_ctx, "TL:  %s %u %c - ref_wait:%u [%s(%u),%s(%u),%s(%u), fd:%d, fence:(0x%08X)]  job:(0x%08X)\n",
+					    tracker_type, tracker->point, state_char, tracker->trigger_ref_count,
+					    is_waiting_on_timeline(tracker, MALI_TIMELINE_GP) ? "WaitGP" : " ", tracker->fence.points[0],
+					    is_waiting_on_timeline(tracker, MALI_TIMELINE_PP) ? "WaitPP" : " ", tracker->fence.points[1],
+					    is_waiting_on_timeline(tracker, MALI_TIMELINE_SOFT) ? "WaitSOFT" : " ", tracker->fence.points[2],
+					    tracker->fence.sync_fd, (unsigned int)(uintptr_t)(tracker->sync_fence), (unsigned int)(uintptr_t)(tracker->job));
+		else
+			MALI_DEBUG_PRINT(2, ("TL:  %s %u %c - ref_wait:%u [%s(%u),%s(%u),%s(%u), fd:%d, fence:(0x%08X)]  job:(0x%08X)\n",
+					     tracker_type, tracker->point, state_char, tracker->trigger_ref_count,
+					     is_waiting_on_timeline(tracker, MALI_TIMELINE_GP) ? "WaitGP" : " ", tracker->fence.points[0],
+					     is_waiting_on_timeline(tracker, MALI_TIMELINE_PP) ? "WaitPP" : " ", tracker->fence.points[1],
+					     is_waiting_on_timeline(tracker, MALI_TIMELINE_SOFT) ? "WaitSOFT" : " ", tracker->fence.points[2],
+					     tracker->fence.sync_fd, (unsigned int)(uintptr_t)(tracker->sync_fence), (unsigned int)(uintptr_t)(tracker->job)));
 	} else {
-		_mali_osk_ctxprintf(print_ctx, "TL:  %s %u %c  fd:%d  fence:(0x%08X)  job:(0x%08X)\n",
-				    tracker_type, tracker->point, state_char,
-				    tracker->fence.sync_fd, (unsigned int)(uintptr_t)(tracker->sync_fence), (unsigned int)(uintptr_t)(tracker->job));
+		if (print_ctx)
+			_mali_osk_ctxprintf(print_ctx, "TL:  %s %u %c  fd:%d  fence:(0x%08X)  job:(0x%08X)\n",
+					    tracker_type, tracker->point, state_char,
+					    tracker->fence.sync_fd, (unsigned int)(uintptr_t)(tracker->sync_fence), (unsigned int)(uintptr_t)(tracker->job));
+		else
+			MALI_DEBUG_PRINT(2, ("TL:  %s %u %c  fd:%d  fence:(0x%08X)  job:(0x%08X)\n",
+					     tracker_type, tracker->point, state_char,
+					     tracker->fence.sync_fd, (unsigned int)(uintptr_t)(tracker->sync_fence), (unsigned int)(uintptr_t)(tracker->job)));
+
 	}
 #else
 	if (0 != tracker->trigger_ref_count) {
-		_mali_osk_ctxprintf(print_ctx, "TL:  %s %u %c - ref_wait:%u [%s(%u),%s(%u),%s(%u)]  job:(0x%08X)\n",
-				    tracker_type, tracker->point, state_char, tracker->trigger_ref_count,
-				    is_waiting_on_timeline(tracker, MALI_TIMELINE_GP) ? "WaitGP" : " ", tracker->fence.points[0],
-				    is_waiting_on_timeline(tracker, MALI_TIMELINE_PP) ? "WaitPP" : " ", tracker->fence.points[1],
-				    is_waiting_on_timeline(tracker, MALI_TIMELINE_SOFT) ? "WaitSOFT" : " ", tracker->fence.points[2],
-				    (unsigned int)(uintptr_t)(tracker->job));
+		if (print_ctx)
+			_mali_osk_ctxprintf(print_ctx, "TL:  %s %u %c - ref_wait:%u [%s(%u),%s(%u),%s(%u)]  job:(0x%08X)\n",
+					    tracker_type, tracker->point, state_char, tracker->trigger_ref_count,
+					    is_waiting_on_timeline(tracker, MALI_TIMELINE_GP) ? "WaitGP" : " ", tracker->fence.points[0],
+					    is_waiting_on_timeline(tracker, MALI_TIMELINE_PP) ? "WaitPP" : " ", tracker->fence.points[1],
+					    is_waiting_on_timeline(tracker, MALI_TIMELINE_SOFT) ? "WaitSOFT" : " ", tracker->fence.points[2],
+					    (unsigned int)(uintptr_t)(tracker->job));
+		else
+			MALI_DEBUG_PRINT(2, ("TL:  %s %u %c - ref_wait:%u [%s(%u),%s(%u),%s(%u)]  job:(0x%08X)\n",
+					     tracker_type, tracker->point, state_char, tracker->trigger_ref_count,
+					     is_waiting_on_timeline(tracker, MALI_TIMELINE_GP) ? "WaitGP" : " ", tracker->fence.points[0],
+					     is_waiting_on_timeline(tracker, MALI_TIMELINE_PP) ? "WaitPP" : " ", tracker->fence.points[1],
+					     is_waiting_on_timeline(tracker, MALI_TIMELINE_SOFT) ? "WaitSOFT" : " ", tracker->fence.points[2],
+					     (unsigned int)(uintptr_t)(tracker->job)));
 	} else {
-		_mali_osk_ctxprintf(print_ctx, "TL:  %s %u %c  job:(0x%08X)\n",
-				    tracker_type, tracker->point, state_char,
-				    (unsigned int)(uintptr_t)(tracker->job));
+		if (print_ctx)
+			_mali_osk_ctxprintf(print_ctx, "TL:  %s %u %c  job:(0x%08X)\n",
+					    tracker_type, tracker->point, state_char,
+					    (unsigned int)(uintptr_t)(tracker->job));
+		else
+			MALI_DEBUG_PRINT(2, ("TL:  %s %u %c  job:(0x%08X)\n",
+					     tracker_type, tracker->point, state_char,
+					     (unsigned int)(uintptr_t)(tracker->job)));
+
 	}
 #endif
 }
@@ -1627,7 +1772,7 @@
 	state_char = *(tracker_state + mali_timeline_debug_get_tracker_state(tracker));
 	_mali_osk_snprintf(tracker_type, sizeof(tracker_type), "%s", timeline_tracker_type_to_string(tracker->type));
 
-#if defined(CONFIG_SYNC)
+#if defined(CONFIG_SYNC) || defined(CONFIG_SYNC_FILE)
 	if (0 != tracker->trigger_ref_count) {
 		MALI_PRINT(("TL:  %s %u %c - ref_wait:%u [%s(%u),%s(%u),%s(%u), fd:%d, fence:(0x%08X)]  job:(0x%08X)\n",
 			    tracker_type, tracker->point, state_char, tracker->trigger_ref_count,
@@ -1688,16 +1833,22 @@
 		MALI_DEBUG_ASSERT_POINTER(timeline);
 
 		if (NULL == timeline->tracker_head) continue;
-
-		_mali_osk_ctxprintf(print_ctx, "TL: Timeline %s:\n",
-				    timeline_id_to_string((enum mali_timeline_id)i));
+		if (print_ctx)
+			_mali_osk_ctxprintf(print_ctx, "TL: Timeline %s:\n",
+					    timeline_id_to_string((enum mali_timeline_id)i));
+		else
+			MALI_DEBUG_PRINT(2, ("TL: Timeline %s: oldest (%u) next(%u)\n",
+					     timeline_id_to_string((enum mali_timeline_id)i), timeline->point_oldest, timeline->point_next));
 
 		mali_timeline_debug_print_timeline(timeline, print_ctx);
 		num_printed++;
 	}
 
 	if (0 == num_printed) {
-		_mali_osk_ctxprintf(print_ctx, "TL: All timelines empty\n");
+		if (print_ctx)
+			_mali_osk_ctxprintf(print_ctx, "TL: All timelines empty\n");
+		else
+			MALI_DEBUG_PRINT(2, ("TL: All timelines empty\n"));
 	}
 
 	mali_spinlock_reentrant_signal(system->spinlock, tid);
diff -Naur driver/src/devicedrv/mali/common/mali_timeline_fence_wait.c driver/src/devicedrv/mali/common/mali_timeline_fence_wait.c
--- driver/src/devicedrv/mali/common/mali_timeline_fence_wait.c	2017-01-20 14:42:05.000000000 +0800
+++ driver/src/devicedrv/mali/common/mali_timeline_fence_wait.c	2017-09-04 10:16:02.226482722 +0800
@@ -1,15 +1,14 @@
 /*
  * This confidential and proprietary software may be used only as
  * authorised by a licensing agreement from ARM Limited
- * (C) COPYRIGHT 2013-2014, 2016-2017 ARM Limited
+ * (C) COPYRIGHT 2013-2014, 2017 ARM Limited
  * ALL RIGHTS RESERVED
  * The entire notice above must be reproduced on all authorised
  * copies and copies may only be made to the extent permitted
  * by a licensing agreement from ARM Limited.
  */
-
+#include <linux/file.h>
 #include "mali_timeline_fence_wait.h"
-
 #include "mali_osk.h"
 #include "mali_kernel_common.h"
 #include "mali_spinlock_reentrant.h"
@@ -64,8 +63,12 @@
 	int i;
 	u32 tid = _mali_osk_get_tid();
 	mali_bool ret = MALI_TRUE;
-#if defined(CONFIG_SYNC)
+#if defined(CONFIG_SYNC) || defined(CONFIG_SYNC_FILE)
+#if LINUX_VERSION_CODE < KERNEL_VERSION(4, 6, 0)
 	struct sync_fence *sync_fence = NULL;
+#else
+	struct mali_internal_sync_fence *sync_fence = NULL;
+#endif
 #endif
 
 	MALI_DEBUG_ASSERT_POINTER(system);
@@ -97,14 +100,20 @@
 		}
 	}
 
-#if defined(CONFIG_SYNC)
+#if defined(CONFIG_SYNC) || defined(CONFIG_SYNC_FILE)
 	if (-1 != fence->sync_fd) {
+#if LINUX_VERSION_CODE < KERNEL_VERSION(4, 6, 0)
 		sync_fence = sync_fence_fdget(fence->sync_fd);
+#else
+		sync_fence = mali_internal_sync_fence_fdget(fence->sync_fd);
+#endif
 		if (likely(NULL != sync_fence)) {
 #if LINUX_VERSION_CODE < KERNEL_VERSION(3, 17, 0)
 			if (0 == sync_fence->status) {
-#else
+#elif LINUX_VERSION_CODE < KERNEL_VERSION(4, 9, 0)
 			if (0 == atomic_read(&sync_fence->status)) {
+#else
+			if (1 == sync_fence->fence->ops->signaled(sync_fence->fence)) {
 #endif
 				ret = MALI_FALSE;
 			}
@@ -112,16 +121,20 @@
 			MALI_PRINT_ERROR(("Mali Timeline: failed to get sync fence from fd %d\n", fence->sync_fd));
 		}
 	}
-#endif /* defined(CONFIG_SYNC) */
+#endif /* defined(CONFIG_SYNC) || defined(CONFIG_SYNC_FILE) */
 
 exit:
 	mali_spinlock_reentrant_signal(system->spinlock, tid);
 
-#if defined(CONFIG_SYNC)
+#if defined(CONFIG_SYNC) || defined(CONFIG_SYNC_FILE)
 	if (NULL != sync_fence) {
+#if LINUX_VERSION_CODE < KERNEL_VERSION(4, 6, 0)
 		sync_fence_put(sync_fence);
+#else
+		fput(sync_fence->file);
+#endif
 	}
-#endif /* defined(CONFIG_SYNC) */
+#endif /* defined(CONFIG_SYNC) || defined(CONFIG_SYNC_FILE) */
 
 	return ret;
 }
diff -Naur driver/src/devicedrv/mali/common/mali_timeline.h driver/src/devicedrv/mali/common/mali_timeline.h
--- driver/src/devicedrv/mali/common/mali_timeline.h	2017-01-20 14:42:05.000000000 +0800
+++ driver/src/devicedrv/mali/common/mali_timeline.h	2017-09-04 10:16:02.230482648 +0800
@@ -114,9 +114,13 @@
 
 	_mali_osk_wait_queue_t         *wait_queue; /**< Wait queue. */
 
-#if defined(CONFIG_SYNC)
+#if defined(CONFIG_SYNC) || defined(CONFIG_SYNC_FILE)
+#if LINUX_VERSION_CODE < KERNEL_VERSION(4, 6, 0)
 	struct sync_timeline           *signaled_sync_tl; /**< Special sync timeline used to create pre-signaled sync fences */
-#endif /* defined(CONFIG_SYNC) */
+#else
+	struct mali_internal_sync_timeline           *signaled_sync_tl; /**< Special sync timeline used to create pre-signaled sync fences */
+#endif
+#endif /* defined(CONFIG_SYNC) || defined(CONFIG_SYNC_FILE) */
 };
 
 /**
@@ -139,11 +143,15 @@
 	struct mali_timeline_system  *system;       /**< Timeline system this timeline belongs to. */
 	enum mali_timeline_id         id;           /**< Timeline type. */
 
-#if defined(CONFIG_SYNC)
+#if defined(CONFIG_SYNC) || defined(CONFIG_SYNC_FILE)
+#if LINUX_VERSION_CODE < KERNEL_VERSION(4, 6, 0)
 	struct sync_timeline         *sync_tl;      /**< Sync timeline that corresponds to this timeline. */
+#else
+	struct mali_internal_sync_timeline *sync_tl;
+#endif
 	mali_bool destroyed;
 	struct mali_spinlock_reentrant *spinlock;       /**< Spin lock protecting the timeline system */
-#endif /* defined(CONFIG_SYNC) */
+#endif /* defined(CONFIG_SYNC) || defined(CONFIG_SYNC_FILE) */
 
 	/* The following fields are used to time out soft job trackers. */
 	_mali_osk_wq_delayed_work_t  *delayed_work;
@@ -183,13 +191,20 @@
 	struct mali_timeline_waiter   *waiter_head;
 	struct mali_timeline_waiter   *waiter_tail;
 
-#if defined(CONFIG_SYNC)
+#if defined(CONFIG_SYNC) || defined(CONFIG_SYNC_FILE)
 	/* These are only used if the tracker is waiting on a sync fence. */
 	struct mali_timeline_waiter   *waiter_sync; /**< A direct pointer to timeline waiter representing sync fence. */
+#if LINUX_VERSION_CODE < KERNEL_VERSION(4, 6, 0)
 	struct sync_fence_waiter       sync_fence_waiter; /**< Used to connect sync fence and tracker in sync fence wait callback. */
 	struct sync_fence             *sync_fence;   /**< The sync fence this tracker is waiting on. */
+#else
+	struct mali_internal_sync_fence_waiter       sync_fence_waiter; /**< Used to connect sync fence and tracker in sync fence wait callback. */
+	struct mali_internal_sync_fence             *sync_fence;   /**< The sync fence this tracker is waiting on. */
+#endif
 	_mali_osk_list_t               sync_fence_cancel_list; /**< List node used to cancel sync fence waiters. */
-#endif /* defined(CONFIG_SYNC) */
+	_mali_osk_list_t                sync_fence_signal_list; /** < List node used to singal sync fence callback function. */
+
+#endif /* defined(CONFIG_SYNC) || defined(CONFIG_SYNC_FILE) */
 
 #if defined(CONFIG_MALI_DMA_BUF_FENCE)
 	struct mali_timeline_waiter   *waiter_dma_fence; /**< A direct pointer to timeline waiter representing dma fence. */
@@ -466,7 +481,7 @@
  */
 void mali_timeline_fence_copy_uk_fence(struct mali_timeline_fence *fence, _mali_uk_fence_t *uk_fence);
 
-void mali_timeline_initialize(void);
+_mali_osk_errcode_t mali_timeline_initialize(void);
 
 void mali_timeline_terminate(void);
 
diff -Naur driver/src/devicedrv/mali/common/mali_timeline_sync_fence.c driver/src/devicedrv/mali/common/mali_timeline_sync_fence.c
--- driver/src/devicedrv/mali/common/mali_timeline_sync_fence.c	2017-01-20 14:42:05.000000000 +0800
+++ driver/src/devicedrv/mali/common/mali_timeline_sync_fence.c	2017-04-27 18:55:11.000000000 +0800
@@ -1,21 +1,20 @@
 /*
  * This confidential and proprietary software may be used only as
  * authorised by a licensing agreement from ARM Limited
- * (C) COPYRIGHT 2013, 2016-2017 ARM Limited
+ * (C) COPYRIGHT 2013, 2017 ARM Limited
  * ALL RIGHTS RESERVED
  * The entire notice above must be reproduced on all authorised
  * copies and copies may only be made to the extent permitted
  * by a licensing agreement from ARM Limited.
  */
-
+#include <linux/file.h>
 #include "mali_timeline_sync_fence.h"
 
 #include "mali_osk.h"
 #include "mali_kernel_common.h"
 #include "mali_sync.h"
 
-#if defined(CONFIG_SYNC)
-
+#if defined(CONFIG_SYNC) || defined(CONFIG_SYNC_FILE)
 /**
  * Creates a sync fence tracker and a sync fence.  Adds sync fence tracker to Timeline system and
  * returns sync fence.  The sync fence will be signaled when the sync fence tracker is activated.
@@ -24,10 +23,18 @@
  * @param point Point on timeline.
  * @return Sync fence that will be signaled when tracker is activated.
  */
+ #if LINUX_VERSION_CODE < KERNEL_VERSION(4, 6, 0)
 static struct sync_fence *mali_timeline_sync_fence_create_and_add_tracker(struct mali_timeline *timeline, mali_timeline_point point)
+#else
+static struct mali_internal_sync_fence *mali_timeline_sync_fence_create_and_add_tracker(struct mali_timeline *timeline, mali_timeline_point point)
+#endif
 {
 	struct mali_timeline_sync_fence_tracker *sync_fence_tracker;
+#if LINUX_VERSION_CODE < KERNEL_VERSION(4, 6, 0)
 	struct sync_fence                       *sync_fence;
+#else
+	struct mali_internal_sync_fence                       *sync_fence;
+#endif
 	struct mali_timeline_fence               fence;
 
 	MALI_DEBUG_ASSERT_POINTER(timeline);
@@ -74,15 +81,21 @@
 s32 mali_timeline_sync_fence_create(struct mali_timeline_system *system, struct mali_timeline_fence *fence)
 {
 	u32 i;
+#if LINUX_VERSION_CODE < KERNEL_VERSION(4, 6, 0)
 	struct sync_fence *sync_fence_acc = NULL;
-
+#else
+	struct mali_internal_sync_fence *sync_fence_acc = NULL;
+#endif
 	MALI_DEBUG_ASSERT_POINTER(system);
 	MALI_DEBUG_ASSERT_POINTER(fence);
 
 	for (i = 0; i < MALI_TIMELINE_MAX; ++i) {
 		struct mali_timeline *timeline;
+#if LINUX_VERSION_CODE < KERNEL_VERSION(4, 6, 0)
 		struct sync_fence *sync_fence;
-
+#else
+		struct mali_internal_sync_fence *sync_fence;
+#endif
 		if (MALI_TIMELINE_NO_POINT == fence->points[i]) continue;
 
 		timeline = system->timelines[i];
@@ -102,9 +115,14 @@
 	}
 
 	if (-1 != fence->sync_fd) {
+#if LINUX_VERSION_CODE < KERNEL_VERSION(4, 6, 0)
 		struct sync_fence *sync_fence;
-
 		sync_fence = sync_fence_fdget(fence->sync_fd);
+#else
+		struct mali_internal_sync_fence *sync_fence;
+		sync_fence = mali_internal_sync_fence_fdget(fence->sync_fd);
+#endif
+		
 		if (NULL == sync_fence) goto error;
 
 		if (NULL != sync_fence_acc) {
@@ -129,7 +147,11 @@
 
 error:
 	if (NULL != sync_fence_acc) {
+#if LINUX_VERSION_CODE < KERNEL_VERSION(4, 6, 0)
 		sync_fence_put(sync_fence_acc);
+#else
+		fput(sync_fence_acc->file);
+#endif
 	}
 
 	return -1;
@@ -154,5 +176,4 @@
 
 	_mali_osk_free(sync_fence_tracker);
 }
-
-#endif /* defined(CONFIG_SYNC) */
+#endif /* defined(CONFIG_SYNC) || defined(CONFIG_SYNC_FILE) */
diff -Naur driver/src/devicedrv/mali/common/mali_timeline_sync_fence.h driver/src/devicedrv/mali/common/mali_timeline_sync_fence.h
--- driver/src/devicedrv/mali/common/mali_timeline_sync_fence.h	2017-01-20 14:42:05.000000000 +0800
+++ driver/src/devicedrv/mali/common/mali_timeline_sync_fence.h	2017-04-27 18:55:11.000000000 +0800
@@ -1,7 +1,7 @@
 /*
  * This confidential and proprietary software may be used only as
  * authorised by a licensing agreement from ARM Limited
- * (C) COPYRIGHT 2013, 2016-2017 ARM Limited
+ * (C) COPYRIGHT 2013, 2017 ARM Limited
  * ALL RIGHTS RESERVED
  * The entire notice above must be reproduced on all authorised
  * copies and copies may only be made to the extent permitted
@@ -19,7 +19,7 @@
 
 #include "mali_timeline.h"
 
-#if defined(CONFIG_SYNC)
+#if defined(CONFIG_SYNC) || defined(CONFIG_SYNC_FILE)
 
 /**
  * Sync fence tracker.
@@ -46,6 +46,6 @@
  */
 void mali_timeline_sync_fence_activate(struct mali_timeline_sync_fence_tracker *sync_fence_tracker);
 
-#endif /* defined(CONFIG_SYNC) */
+#endif /* defined(CONFIG_SYNC) || defined(CONFIG_SYNC_FILE) */
 
 #endif /* __MALI_TIMELINE_SYNC_FENCE_H__ */
diff -Naur driver/src/devicedrv/mali/Kbuild driver/src/devicedrv/mali/Kbuild
--- driver/src/devicedrv/mali/Kbuild	2017-01-20 14:42:04.000000000 +0800
+++ driver/src/devicedrv/mali/Kbuild	2017-04-27 18:55:11.000000000 +0800
@@ -155,8 +155,12 @@
 mali-$(CONFIG_DMA_SHARED_BUFFER) += linux/mali_memory_dma_buf.o
 mali-$(CONFIG_DMA_SHARED_BUFFER) += linux/mali_memory_secure.o
 mali-$(CONFIG_SYNC) += linux/mali_sync.o
+mali-$(CONFIG_SYNC) += linux/mali_internal_sync.o
+mali-$(CONFIG_SYNC_FILE) += linux/mali_sync.o
+mali-$(CONFIG_SYNC_FILE) += linux/mali_internal_sync.o
 mali-$(CONFIG_MALI_DMA_BUF_FENCE) += linux/mali_dma_fence.o
 ccflags-$(CONFIG_SYNC) += -Idrivers/staging/android
+ccflags-$(CONFIG_SYNC_FILE) += -Idrivers/staging/android
 
 mali-$(CONFIG_MALI400_UMP) += linux/mali_memory_ump.o
 
diff -Naur driver/src/devicedrv/mali/linux/license/proprietary/mali_kernel_license.h driver/src/devicedrv/mali/linux/license/proprietary/mali_kernel_license.h
--- driver/src/devicedrv/mali/linux/license/proprietary/mali_kernel_license.h	2017-01-20 14:42:04.000000000 +0800
+++ driver/src/devicedrv/mali/linux/license/proprietary/mali_kernel_license.h	2017-04-27 18:55:11.000000000 +0800
@@ -1,7 +1,7 @@
 /*
  * This confidential and proprietary software may be used only as
  * authorised by a licensing agreement from ARM Limited
- * (C) COPYRIGHT 2010, 2013, 2016-2017 ARM Limited
+ * (C) COPYRIGHT 2010, 2013, 2017 ARM Limited
  * ALL RIGHTS RESERVED
  * The entire notice above must be reproduced on all authorised
  * copies and copies may only be made to the extent permitted
diff -Naur driver/src/devicedrv/mali/linux/mali_dma_fence.c driver/src/devicedrv/mali/linux/mali_dma_fence.c
--- driver/src/devicedrv/mali/linux/mali_dma_fence.c	2017-01-20 14:42:04.000000000 +0800
+++ driver/src/devicedrv/mali/linux/mali_dma_fence.c	2017-09-04 10:16:02.234482575 +0800
@@ -19,6 +19,34 @@
 
 static DEFINE_SPINLOCK(mali_dma_fence_lock);
 
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(4, 10, 0)
+static bool mali_dma_fence_enable_signaling(struct dma_fence *fence)
+{
+	MALI_IGNORE(fence);
+	return true;
+}
+
+static const char *mali_dma_fence_get_driver_name(struct dma_fence *fence)
+{
+	MALI_IGNORE(fence);
+	return "mali";
+}
+
+static const char *mali_dma_fence_get_timeline_name(struct dma_fence *fence)
+{
+	MALI_IGNORE(fence);
+	return "mali_dma_fence";
+}
+
+static const struct dma_fence_ops mali_dma_fence_ops = {
+	.get_driver_name = mali_dma_fence_get_driver_name,
+	.get_timeline_name = mali_dma_fence_get_timeline_name,
+	.enable_signaling = mali_dma_fence_enable_signaling,
+	.signaled = NULL,
+	.wait = dma_fence_default_wait,
+	.release = NULL
+};
+#else
 static bool mali_dma_fence_enable_signaling(struct fence *fence)
 {
 	MALI_IGNORE(fence);
@@ -45,6 +73,7 @@
 	.wait = fence_default_wait,
 	.release = NULL
 };
+#endif
 
 static void mali_dma_fence_context_cleanup(struct mali_dma_fence_context *dma_fence_context)
 {
@@ -54,9 +83,16 @@
 
 	for (i = 0; i < dma_fence_context->num_dma_fence_waiter; i++) {
 		if (dma_fence_context->mali_dma_fence_waiters[i]) {
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(4, 10, 0)
+			dma_fence_remove_callback(dma_fence_context->mali_dma_fence_waiters[i]->fence,
+						  &dma_fence_context->mali_dma_fence_waiters[i]->base);
+			dma_fence_put(dma_fence_context->mali_dma_fence_waiters[i]->fence);
+
+#else
 			fence_remove_callback(dma_fence_context->mali_dma_fence_waiters[i]->fence,
 					      &dma_fence_context->mali_dma_fence_waiters[i]->base);
 			fence_put(dma_fence_context->mali_dma_fence_waiters[i]->fence);
+#endif
 			kfree(dma_fence_context->mali_dma_fence_waiters[i]);
 			dma_fence_context->mali_dma_fence_waiters[i] = NULL;
 		}
@@ -80,7 +116,11 @@
 	dma_fence_context->cb_func(dma_fence_context->pp_job_ptr);
 }
 
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(4, 10, 0)
+static void mali_dma_fence_callback(struct dma_fence *fence, struct dma_fence_cb *cb)
+#else
 static void mali_dma_fence_callback(struct fence *fence, struct fence_cb *cb)
+#endif
 {
 	struct mali_dma_fence_waiter *dma_fence_waiter = NULL;
 	struct mali_dma_fence_context *dma_fence_context = NULL;
@@ -99,7 +139,11 @@
 		schedule_work(&dma_fence_context->work_handle);
 }
 
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(4, 10, 0)
+static _mali_osk_errcode_t mali_dma_fence_add_callback(struct mali_dma_fence_context *dma_fence_context, struct dma_fence *fence)
+#else
 static _mali_osk_errcode_t mali_dma_fence_add_callback(struct mali_dma_fence_context *dma_fence_context, struct fence *fence)
+#endif
 {
 	int ret = 0;
 	struct mali_dma_fence_waiter *dma_fence_waiter;
@@ -127,16 +171,27 @@
 		return _MALI_OSK_ERR_NOMEM;
 	}
 
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(4, 10, 0)
+	dma_fence_get(fence);
+#else
 	fence_get(fence);
-
+#endif
 	dma_fence_waiter->fence = fence;
 	dma_fence_waiter->parent = dma_fence_context;
 	atomic_inc(&dma_fence_context->count);
-
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(4, 10, 0)
+	ret = dma_fence_add_callback(fence, &dma_fence_waiter->base,
+				 mali_dma_fence_callback);
+#else
 	ret = fence_add_callback(fence, &dma_fence_waiter->base,
 				 mali_dma_fence_callback);
+#endif
 	if (0 > ret) {
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(4, 10, 0)
+		dma_fence_put(fence);
+#else
 		fence_put(fence);
+#endif
 		kfree(dma_fence_waiter);
 		atomic_dec(&dma_fence_context->count);
 		if (-ENOENT == ret) {
@@ -155,32 +210,52 @@
 }
 
 
+ #if LINUX_VERSION_CODE >= KERNEL_VERSION(4, 10, 0)
+ struct dma_fence *mali_dma_fence_new(u32  context, u32 seqno)
+ #else
 struct fence *mali_dma_fence_new(u32  context, u32 seqno)
+#endif
 {
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(4, 10, 0)
+	struct dma_fence *fence = NULL;
+	fence = kzalloc(sizeof(struct dma_fence), GFP_KERNEL);
+#else
 	struct fence *fence = NULL;
-
-	fence = kzalloc(sizeof(*fence), GFP_KERNEL);
-
+	fence = kzalloc(sizeof(struct fence), GFP_KERNEL);
+#endif
 	if (NULL == fence) {
 		MALI_DEBUG_PRINT(1, ("Mali dma fence: failed to create dma fence.\n"));
 		return fence;
 	}
-
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(4, 10, 0)
+	dma_fence_init(fence,
+		   &mali_dma_fence_ops,
+		   &mali_dma_fence_lock,
+		   context, seqno);
+#else
 	fence_init(fence,
 		   &mali_dma_fence_ops,
 		   &mali_dma_fence_lock,
 		   context, seqno);
-
+#endif
 	return fence;
 }
 
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(4, 10, 0)
+void mali_dma_fence_signal_and_put(struct dma_fence **fence)
+#else
 void mali_dma_fence_signal_and_put(struct fence **fence)
+#endif
 {
 	MALI_DEBUG_ASSERT_POINTER(fence);
 	MALI_DEBUG_ASSERT_POINTER(*fence);
-
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(4, 10, 0)
+	dma_fence_signal(*fence);
+	dma_fence_put(*fence);
+#else
 	fence_signal(*fence);
 	fence_put(*fence);
+#endif
 	*fence = NULL;
 }
 
@@ -202,10 +277,14 @@
 		struct reservation_object *dma_reservation_object)
 {
 	_mali_osk_errcode_t ret = _MALI_OSK_ERR_OK;
-	struct fence *exclusive_fence = NULL;
 	u32 shared_count = 0, i;
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(4, 10, 0)
+	struct dma_fence *exclusive_fence = NULL;
+	struct dma_fence **shared_fences = NULL;
+#else
+	struct fence *exclusive_fence = NULL;
 	struct fence **shared_fences = NULL;
-
+#endif
 	MALI_DEBUG_ASSERT_POINTER(dma_fence_context);
 	MALI_DEBUG_ASSERT_POINTER(dma_reservation_object);
 
@@ -239,11 +318,19 @@
 ended:
 
 	if (exclusive_fence)
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(4, 10, 0)
+		dma_fence_put(exclusive_fence);
+#else
 		fence_put(exclusive_fence);
+#endif
 
 	if (shared_fences) {
 		for (i = 0; i < shared_count; i++) {
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(4, 10, 0)
+			dma_fence_put(shared_fences[i]);
+#else
 			fence_put(shared_fences[i]);
+#endif
 		}
 		kfree(shared_fences);
 	}
diff -Naur driver/src/devicedrv/mali/linux/mali_dma_fence.h driver/src/devicedrv/mali/linux/mali_dma_fence.h
--- driver/src/devicedrv/mali/linux/mali_dma_fence.h	2017-01-20 14:42:04.000000000 +0800
+++ driver/src/devicedrv/mali/linux/mali_dma_fence.h	2017-09-04 10:16:02.234482575 +0800
@@ -18,7 +18,11 @@
 #define _MALI_DMA_FENCE_H_
 
 #if LINUX_VERSION_CODE >= KERNEL_VERSION(3, 17, 0)
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(4, 10, 0)
+#include <linux/dma-fence.h>
+#else
 #include <linux/fence.h>
+#endif
 #include <linux/reservation.h>
 #endif
 
@@ -28,9 +32,14 @@
 typedef void (*mali_dma_fence_context_callback_func_t)(void *pp_job_ptr);
 
 struct mali_dma_fence_waiter {
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(4, 10, 0)
+	struct dma_fence *fence;
+	struct dma_fence_cb base;
+#else
 	struct fence_cb base;
-	struct mali_dma_fence_context *parent;
 	struct fence *fence;
+#endif
+	struct mali_dma_fence_context *parent;
 };
 
 struct mali_dma_fence_context {
@@ -47,13 +56,19 @@
  * @param seqno A linearly increasing sequence number for this context
  * @return the new dma fence if success, or NULL on failure.
  */
+ #if LINUX_VERSION_CODE >= KERNEL_VERSION(4, 10, 0)
+ struct dma_fence *mali_dma_fence_new(u32  context, u32 seqno);
+ #else
 struct fence *mali_dma_fence_new(u32  context, u32 seqno);
-
+#endif
 /* Signal and put dma fence
  * @param fence The dma fence to signal and put
  */
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(4, 10, 0)
+void mali_dma_fence_signal_and_put(struct dma_fence **fence);
+#else
 void mali_dma_fence_signal_and_put(struct fence **fence);
-
+#endif
 /**
  * Initialize a mali dma fence context for pp job.
  * @param dma_fence_context The mali dma fence context to initialize.
diff -Naur driver/src/devicedrv/mali/linux/mali_internal_sync.c driver/src/devicedrv/mali/linux/mali_internal_sync.c
--- driver/src/devicedrv/mali/linux/mali_internal_sync.c	1970-01-01 08:00:00.000000000 +0800
+++ driver/src/devicedrv/mali/linux/mali_internal_sync.c	2017-09-04 10:16:02.234482575 +0800
@@ -0,0 +1,738 @@
+/*
+ * This confidential and proprietary software may be used only as
+ * authorised by a licensing agreement from ARM Limited
+ * (C) COPYRIGHT 2012-2016 ARM Limited
+ * ALL RIGHTS RESERVED
+ * The entire notice above must be reproduced on all authorised
+ * copies and copies may only be made to the extent permitted
+ * by a licensing agreement from ARM Limited.
+ */
+
+#include "mali_internal_sync.h"
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(4, 6, 0)
+#include <linux/ioctl.h>
+#include <linux/export.h>
+#include <linux/file.h>
+#include <linux/fs.h>
+#include <linux/kernel.h>
+#include <linux/poll.h>
+#include <linux/sched.h>
+#include <linux/seq_file.h>
+#include <linux/slab.h>
+#include <linux/uaccess.h>
+#include <linux/anon_inodes.h>
+
+#include "mali_osk.h"
+#include "mali_kernel_common.h"
+#if defined(DEBUG)
+#include "mali_session.h"
+#include "mali_timeline.h"
+#endif
+
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(4, 10, 0)
+static const struct dma_fence_ops fence_ops;
+#else
+static const struct fence_ops fence_ops;
+#endif
+
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(4, 10, 0)
+static struct mali_internal_sync_point *mali_internal_fence_to_sync_pt(struct dma_fence *fence)
+#else
+static struct mali_internal_sync_point *mali_internal_fence_to_sync_pt(struct fence *fence)
+#endif
+{
+	MALI_DEBUG_ASSERT_POINTER(fence);
+	return container_of(fence, struct mali_internal_sync_point, base);
+}
+
+static inline struct mali_internal_sync_timeline *mali_internal_sync_pt_to_sync_timeline(struct mali_internal_sync_point *sync_pt)
+{
+	MALI_DEBUG_ASSERT_POINTER(sync_pt);
+	return container_of(sync_pt->base.lock, struct mali_internal_sync_timeline, sync_pt_list_lock);
+}
+
+static void mali_internal_sync_timeline_free(struct kref *kref_count)
+{
+	struct mali_internal_sync_timeline *sync_timeline;
+
+	MALI_DEBUG_ASSERT_POINTER(kref_count);
+
+	sync_timeline = container_of(kref_count, struct mali_internal_sync_timeline, kref_count);
+
+	if (sync_timeline->ops->release_obj)
+		sync_timeline->ops->release_obj(sync_timeline);
+
+	kfree(sync_timeline);
+}
+
+#if LINUX_VERSION_CODE < KERNEL_VERSION(4, 10, 0)
+static void mali_internal_fence_check_cb_func(struct fence *fence, struct fence_cb *cb)
+#else
+static void mali_internal_fence_check_cb_func(struct dma_fence *fence, struct dma_fence_cb *cb)
+#endif
+{
+#if LINUX_VERSION_CODE < KERNEL_VERSION(4, 9, 0)
+	struct mali_internal_sync_fence_cb *check;
+#endif
+	struct mali_internal_sync_fence *sync_fence;
+	int ret;
+	MALI_DEBUG_ASSERT_POINTER(cb);
+	MALI_IGNORE(fence);
+#if LINUX_VERSION_CODE < KERNEL_VERSION(4, 9, 0)
+	check = container_of(cb, struct mali_internal_sync_fence_cb, cb);
+	sync_fence = check->sync_file;
+#else
+	MALI_DEBUG_ASSERT_POINTER(fence);
+	MALI_IGNORE(cb);
+	sync_fence = container_of(&fence, struct mali_internal_sync_fence, fence);
+#endif
+
+#if LINUX_VERSION_CODE < KERNEL_VERSION(4, 9, 0)
+	ret = atomic_dec_and_test(&sync_fence->status);
+	if (ret)
+		wake_up_all(&sync_fence->wq);
+#else	
+	ret =sync_fence->fence->ops->signaled(sync_fence->fence);
+
+	if (0 > ret)
+		MALI_PRINT_ERROR(("Mali internal sync:Failed to wait fence  0x%x for sync_fence 0x%x.\n", fence, sync_fence));
+	if (1 == ret)
+		wake_up_all(&sync_fence->wq);
+#endif	
+}
+
+#if LINUX_VERSION_CODE < KERNEL_VERSION(4, 9, 0)
+static void mali_internal_sync_fence_add_fence(struct mali_internal_sync_fence *sync_fence, struct fence *sync_pt)
+{
+	int fence_num = 0;
+	MALI_DEBUG_ASSERT_POINTER(sync_fence);
+	MALI_DEBUG_ASSERT_POINTER(sync_pt);
+
+	fence_num = sync_fence->num_fences;
+
+	sync_fence->cbs[fence_num].fence = sync_pt;
+	sync_fence->cbs[fence_num].sync_file = sync_fence;
+
+	if (!fence_add_callback(sync_pt, &sync_fence->cbs[fence_num].cb, mali_internal_fence_check_cb_func)) {
+		fence_get(sync_pt);
+		sync_fence->num_fences++;
+		atomic_inc(&sync_fence->status);
+	}
+}
+#endif
+
+static int mali_internal_sync_fence_wake_up_wq(wait_queue_t *curr, unsigned mode,
+		int wake_flags, void *key)
+{
+	struct mali_internal_sync_fence_waiter *wait;
+	MALI_IGNORE(mode);
+	MALI_IGNORE(wake_flags);
+	MALI_IGNORE(key);
+
+	wait = container_of(curr, struct mali_internal_sync_fence_waiter, work);
+	list_del_init(&wait->work.task_list);
+
+	wait->callback(wait->work.private, wait);
+	return 1;
+}
+
+struct mali_internal_sync_timeline *mali_internal_sync_timeline_create(const struct mali_internal_sync_timeline_ops *ops,
+		int size, const char *name)
+{
+	struct mali_internal_sync_timeline *sync_timeline = NULL;
+
+	MALI_DEBUG_ASSERT_POINTER(ops);
+
+	if (size < sizeof(struct mali_internal_sync_timeline)) {
+		MALI_PRINT_ERROR(("Mali internal sync:Invalid size to create the mali internal sync timeline.\n"));
+		goto err;
+	}
+
+	sync_timeline = kzalloc(size, GFP_KERNEL);
+	if (NULL == sync_timeline) {
+		MALI_PRINT_ERROR(("Mali internal sync:Failed to  allocate buffer  for the mali internal sync timeline.\n"));
+		goto err;
+	}
+	kref_init(&sync_timeline->kref_count);
+	sync_timeline->ops = ops;
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(4, 10, 0)
+	sync_timeline->fence_context = dma_fence_context_alloc(1);
+#else
+	sync_timeline->fence_context = fence_context_alloc(1);
+#endif
+	strlcpy(sync_timeline->name, name, sizeof(sync_timeline->name));
+
+	INIT_LIST_HEAD(&sync_timeline->sync_pt_list_head);
+	spin_lock_init(&sync_timeline->sync_pt_list_lock);
+
+	return sync_timeline;
+err:
+	if (NULL != sync_timeline) {
+		kfree(sync_timeline);
+	}
+	return NULL;
+}
+
+void mali_internal_sync_timeline_destroy(struct mali_internal_sync_timeline *sync_timeline)
+{
+	MALI_DEBUG_ASSERT_POINTER(sync_timeline);
+
+	sync_timeline->destroyed = MALI_TRUE;
+
+	smp_wmb();
+
+	mali_internal_sync_timeline_signal(sync_timeline);
+	kref_put(&sync_timeline->kref_count, mali_internal_sync_timeline_free);
+}
+
+void mali_internal_sync_timeline_signal(struct mali_internal_sync_timeline *sync_timeline)
+{
+	unsigned long flags;
+	struct mali_internal_sync_point *sync_pt, *next;
+
+	MALI_DEBUG_ASSERT_POINTER(sync_timeline);
+
+	spin_lock_irqsave(&sync_timeline->sync_pt_list_lock, flags);
+
+	list_for_each_entry_safe(sync_pt, next, &sync_timeline->sync_pt_list_head,
+				 sync_pt_list) {
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(4, 10, 0)
+		if (dma_fence_is_signaled_locked(&sync_pt->base))
+#else
+		if (fence_is_signaled_locked(&sync_pt->base))
+#endif
+			list_del_init(&sync_pt->sync_pt_list);
+	}
+
+	spin_unlock_irqrestore(&sync_timeline->sync_pt_list_lock, flags);
+}
+
+struct mali_internal_sync_point *mali_internal_sync_point_create(struct mali_internal_sync_timeline *sync_timeline, int size)
+{
+	unsigned long flags;
+	struct mali_internal_sync_point *sync_pt = NULL;
+
+	MALI_DEBUG_ASSERT_POINTER(sync_timeline);
+
+	if (size < sizeof(struct mali_internal_sync_point)) {
+		MALI_PRINT_ERROR(("Mali internal sync:Invalid size to create the mali internal sync point.\n"));
+		goto err;
+	}
+
+	sync_pt = kzalloc(size, GFP_KERNEL);
+	if (NULL == sync_pt) {
+		MALI_PRINT_ERROR(("Mali internal sync:Failed to  allocate buffer  for the mali internal sync point.\n"));
+		goto err;
+	}
+	spin_lock_irqsave(&sync_timeline->sync_pt_list_lock, flags);
+	kref_get(&sync_timeline->kref_count);
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(4, 10, 0)
+	dma_fence_init(&sync_pt->base, &fence_ops, &sync_timeline->sync_pt_list_lock,
+		       sync_timeline->fence_context, ++sync_timeline->value);
+#else
+	fence_init(&sync_pt->base, &fence_ops, &sync_timeline->sync_pt_list_lock,
+		   sync_timeline->fence_context, ++sync_timeline->value);
+#endif
+	INIT_LIST_HEAD(&sync_pt->sync_pt_list);
+	spin_unlock_irqrestore(&sync_timeline->sync_pt_list_lock, flags);
+
+	return sync_pt;
+err:
+	if (NULL != sync_pt) {
+		kfree(sync_pt);
+	}
+	return NULL;
+}
+
+struct mali_internal_sync_fence *mali_internal_sync_fence_fdget(int fd)
+{
+	struct file *file = fget(fd);
+
+	if (NULL == file) {
+		return NULL;
+	}
+
+	return file->private_data;
+}
+
+#if LINUX_VERSION_CODE < KERNEL_VERSION(4, 9, 0)
+struct mali_internal_sync_fence *mali_internal_sync_fence_merge(
+	struct mali_internal_sync_fence *sync_fence1, struct mali_internal_sync_fence *sync_fence2)
+{
+	struct mali_internal_sync_fence *new_sync_fence;
+	int i, j, num_fence1, num_fence2, total_fences;
+	struct fence *fence0 = NULL;
+
+	MALI_DEBUG_ASSERT_POINTER(sync_fence1);
+	MALI_DEBUG_ASSERT_POINTER(sync_fence2);
+
+	num_fence1 = sync_fence1->num_fences;
+	num_fence2 = sync_fence2->num_fences;
+
+	total_fences = num_fence1 + num_fence2;
+
+	i =0;
+	j = 0;
+	
+	if (num_fence1 > 0) {
+		fence0 = sync_fence1->cbs[i].fence;
+		i = 1;
+	}
+	else if(num_fence2 > 0) {
+		fence0 = sync_fence2->cbs[i].fence;
+		j =1;
+	}
+		
+	new_sync_fence = (struct mali_internal_sync_fence *)sync_file_create(fence0);
+	if (NULL == new_sync_fence) {
+		MALI_PRINT_ERROR(("Mali internal sync:Failed to  create the mali internal sync fence when merging sync fence.\n"));
+		return NULL;
+	}
+
+	for (; i < num_fence1 && j < num_fence2;) {
+		struct fence *fence1 = sync_fence1->cbs[i].fence;
+		struct fence *fence2 = sync_fence2->cbs[j].fence;
+
+		if (fence1->context < fence2->context) {
+			mali_internal_sync_fence_add_fence(new_sync_fence, fence1);
+
+			i++;
+		} else if (fence1->context > fence2->context) {
+			mali_internal_sync_fence_add_fence(new_sync_fence, fence2);
+
+			j++;
+		} else {
+			if (fence1->seqno - fence2->seqno <= INT_MAX)
+				mali_internal_sync_fence_add_fence(new_sync_fence, fence1);
+			else
+				mali_internal_sync_fence_add_fence(new_sync_fence, fence2);
+			i++;
+			j++;
+		}
+	}
+
+	for (; i < num_fence1; i++)
+		mali_internal_sync_fence_add_fence(new_sync_fence, sync_fence1->cbs[i].fence);
+
+	for (; j < num_fence2; j++)
+		mali_internal_sync_fence_add_fence(new_sync_fence, sync_fence2->cbs[j].fence);
+
+	return new_sync_fence;
+}
+#else
+#if LINUX_VERSION_CODE < KERNEL_VERSION(4, 10, 0)
+static struct fence **mali_internal_get_fences(struct mali_internal_sync_fence *sync_fence, int *num_fences)
+#else
+static struct dma_fence **mali_internal_get_fences(struct mali_internal_sync_fence *sync_fence, int *num_fences)
+#endif
+{
+#if LINUX_VERSION_CODE < KERNEL_VERSION(4, 10, 0)
+	if (sync_fence->fence->ops == &fence_array_ops) {
+		struct fence_array *fence_array = container_of(sync_fence->fence, struct fence_array, base);
+		*num_fences = fence_array->num_fences;
+		return fence_array->fences;
+	}
+#else
+	if (sync_fence->fence->ops == &dma_fence_array_ops) {
+		struct dma_fence_array *fence_array = container_of(sync_fence->fence, struct dma_fence_array, base);
+		*num_fences = fence_array->num_fences;
+		return fence_array->fences;
+	}
+#endif
+	*num_fences = 1;
+	return &sync_fence->fence;
+}
+
+#if LINUX_VERSION_CODE < KERNEL_VERSION(4, 10, 0)
+static void mali_internal_add_fence_array(struct fence **fences, int *num_fences, struct fence *fence)
+#else
+static void mali_internal_add_fence_array(struct dma_fence **fences, int *num_fences, struct dma_fence *fence)
+#endif
+{
+	fences[*num_fences] = fence;
+#if LINUX_VERSION_CODE < KERNEL_VERSION(4, 10, 0)
+	if (!fence_is_signaled(fence)) {
+		fence_get(fence);
+		(*num_fences)++;
+	}
+#else
+	if (!dma_fence_is_signaled(fence)) {
+		dma_fence_get(fence);
+		(*num_fences)++;
+	}
+#endif
+}
+
+#if LINUX_VERSION_CODE < KERNEL_VERSION(4, 10, 0)
+static int mali_internal_sync_fence_set_fence_array(struct mali_internal_sync_fence *sync_fence,
+			       struct fence **fences, int num_fences)
+#else
+static int mali_internal_sync_fence_set_fence_array(struct mali_internal_sync_fence *sync_fence,
+			       struct dma_fence **fences, int num_fences)
+#endif
+{
+#if LINUX_VERSION_CODE < KERNEL_VERSION(4, 10, 0)
+	struct fence_array *array;
+#else
+	struct dma_fence_array *array;
+#endif
+	MALI_DEBUG_ASSERT(1 != num_fences);
+#if LINUX_VERSION_CODE < KERNEL_VERSION(4, 10, 0)
+	array = fence_array_create(num_fences, fences,
+					   fence_context_alloc(1), 1, false);
+#else
+	array = dma_fence_array_create(num_fences, fences,
+					   dma_fence_context_alloc(1), 1, false);
+#endif
+	if (!array)
+		return -ENOMEM;
+
+	sync_fence->fence = &array->base;
+
+	return 0;
+}
+
+struct mali_internal_sync_fence *mali_internal_sync_fence_merge(
+	struct mali_internal_sync_fence *sync_fence1, struct mali_internal_sync_fence *sync_fence2)
+{
+		struct mali_internal_sync_fence *sync_fence;
+#if LINUX_VERSION_CODE < KERNEL_VERSION(4, 10, 0)
+		struct fence **fences, **nfences, **fences1, **fences2;
+#else
+		struct dma_fence **fences, **nfences, **fences1, **fences2;
+#endif
+		int real_num_fences, i, j, num_fences, num_fences1, num_fences2;
+
+		fences1 = mali_internal_get_fences(sync_fence1, &num_fences1);
+		fences2 = mali_internal_get_fences(sync_fence2, &num_fences2);
+		
+		num_fences = num_fences1 + num_fences2;
+	
+		fences = kcalloc(num_fences, sizeof(*fences), GFP_KERNEL);
+		if (!fences) {
+			MALI_PRINT_ERROR(("Mali internal sync:Failed to  alloc buffer for fences.\n"));
+			goto fences_alloc_failed;
+		}
+
+		for (real_num_fences = i = j = 0; i < num_fences1 && j < num_fences2; ) {
+#if LINUX_VERSION_CODE < KERNEL_VERSION(4, 10, 0)
+			struct fence *fence1 = fences1[i];
+			struct fence *fence2 = fences2[j];
+#else
+			struct dma_fence *fence1 = fences1[i];
+			struct dma_fence *fence2 = fences2[j];
+#endif
+			if (fence1->context < fence2->context) {
+				mali_internal_add_fence_array(fences, &real_num_fences, fence1);
+	
+				i++;
+			} else if (fence1->context > fence2->context) {
+				mali_internal_add_fence_array(fences, &real_num_fences, fence2);
+	
+				j++;
+			} else {
+				if (fence1->seqno - fence2->seqno <= INT_MAX)
+					mali_internal_add_fence_array(fences, &real_num_fences, fence1);
+				else
+					mali_internal_add_fence_array(fences, &real_num_fences, fence2);
+	
+				i++;
+				j++;
+			}
+		}
+	
+		for (; i < num_fences1; i++)
+			mali_internal_add_fence_array(fences, &real_num_fences, fences1[i]);
+	
+		for (; j < num_fences2; j++)
+			mali_internal_add_fence_array(fences, &real_num_fences, fences2[j]);
+
+		if (0 == real_num_fences)
+#if LINUX_VERSION_CODE < KERNEL_VERSION(4, 10, 0)
+			fences[real_num_fences++] = fence_get(fences1[0]);
+#else
+			fences[real_num_fences++] = dma_fence_get(fences1[0]);
+#endif
+	
+		if (num_fences > real_num_fences) {
+			nfences = krealloc(fences, real_num_fences * sizeof(*fences),
+					  GFP_KERNEL);
+			if (!nfences)
+				goto nfences_alloc_failed;
+	
+			fences = nfences;
+		}
+
+		sync_fence = (struct mali_internal_sync_fence *)sync_file_create(fences[0]);
+		if (NULL == sync_fence) {
+			MALI_PRINT_ERROR(("Mali internal sync:Failed to  create the mali internal sync fence when merging sync fence.\n"));
+			goto sync_fence_alloc_failed;
+		}
+	
+		if (mali_internal_sync_fence_set_fence_array(sync_fence, fences, real_num_fences) < 0) {
+			MALI_PRINT_ERROR(("Mali internal sync:Failed to  set fence for sync fence.\n"));
+			goto sync_fence_set_failed;
+		}
+	
+		return sync_fence;
+
+sync_fence_set_failed:
+	fput(sync_fence->file);
+sync_fence_alloc_failed:
+	for (i = 0; i < real_num_fences; i++)
+#if LINUX_VERSION_CODE < KERNEL_VERSION(4, 10, 0)
+		fence_put(fences[i]);
+#else
+		dma_fence_put(fences[i]);
+#endif
+nfences_alloc_failed:
+	kfree(fences);
+fences_alloc_failed:
+	return NULL;
+}
+#endif
+
+void mali_internal_sync_fence_waiter_init(struct mali_internal_sync_fence_waiter *waiter,
+		mali_internal_sync_callback_t callback)
+{
+	MALI_DEBUG_ASSERT_POINTER(waiter);
+	MALI_DEBUG_ASSERT_POINTER(callback);
+
+	INIT_LIST_HEAD(&waiter->work.task_list);
+	waiter->callback = callback;
+}
+
+int mali_internal_sync_fence_wait_async(struct mali_internal_sync_fence *sync_fence,
+					struct mali_internal_sync_fence_waiter *waiter)
+{
+	int err;
+	unsigned long flags;
+
+	MALI_DEBUG_ASSERT_POINTER(sync_fence);
+	MALI_DEBUG_ASSERT_POINTER(waiter);
+#if LINUX_VERSION_CODE < KERNEL_VERSION(4, 9, 0)
+	err = atomic_read(&sync_fence->status);
+
+	if (0 > err)
+		return err;
+
+	if (!err)
+		return 1;
+
+	init_waitqueue_func_entry(&waiter->work, mali_internal_sync_fence_wake_up_wq);
+	waiter->work.private = sync_fence;
+
+	spin_lock_irqsave(&sync_fence->wq.lock, flags);
+	err = atomic_read(&sync_fence->status);
+
+	if (0 < err)
+		__add_wait_queue_tail(&sync_fence->wq, &waiter->work);
+	spin_unlock_irqrestore(&sync_fence->wq.lock, flags);
+
+	if (0 > err)
+		return err;
+
+	return !err;
+#else
+	if ((sync_fence->fence) && (sync_fence->fence->ops) && (sync_fence->fence->ops->signaled))
+		err = sync_fence->fence->ops->signaled(sync_fence->fence);
+	else
+		err = -1;
+
+	if (0 > err)
+		return err;
+
+	if (1 == err)
+		return err;
+
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(4, 10, 0)
+	err = dma_fence_add_callback(sync_fence->fence, &sync_fence->cb, mali_internal_fence_check_cb_func);
+#elif LINUX_VERSION_CODE >= KERNEL_VERSION(4, 9, 0)
+	err = fence_add_callback(sync_fence->fence, &sync_fence->cb, mali_internal_fence_check_cb_func);
+#endif
+
+	if (0 != err)
+		return err;
+
+	init_waitqueue_func_entry(&waiter->work, mali_internal_sync_fence_wake_up_wq);
+	waiter->work.private = sync_fence;
+
+	spin_lock_irqsave(&sync_fence->wq.lock, flags);
+	err =  sync_fence->fence->ops->signaled(sync_fence->fence);
+
+	if (0 == err)
+		__add_wait_queue_tail(&sync_fence->wq, &waiter->work);
+	spin_unlock_irqrestore(&sync_fence->wq.lock, flags);
+
+	return err;
+#endif
+}
+
+int mali_internal_sync_fence_cancel_async(struct mali_internal_sync_fence *sync_fence,
+		struct mali_internal_sync_fence_waiter *waiter)
+{
+	unsigned long flags;
+	int ret = 0;
+
+	MALI_DEBUG_ASSERT_POINTER(sync_fence);
+	MALI_DEBUG_ASSERT_POINTER(waiter);
+
+	spin_lock_irqsave(&sync_fence->wq.lock, flags);
+	if (!list_empty(&waiter->work.task_list))
+		list_del_init(&waiter->work.task_list);
+	else
+		ret = -ENOENT;
+	spin_unlock_irqrestore(&sync_fence->wq.lock, flags);
+
+	return ret;
+}
+
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(4, 10, 0)
+static const char *mali_internal_fence_get_driver_name(struct dma_fence *fence)
+#else
+static const char *mali_internal_fence_get_driver_name(struct fence *fence)
+#endif
+{
+	struct mali_internal_sync_point *sync_pt;
+	struct mali_internal_sync_timeline *parent;
+
+	MALI_DEBUG_ASSERT_POINTER(fence);
+
+	sync_pt = mali_internal_fence_to_sync_pt(fence);
+	parent = mali_internal_sync_pt_to_sync_timeline(sync_pt);
+
+	return parent->ops->driver_name;
+}
+
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(4, 10, 0)
+static const char *mali_internal_fence_get_timeline_name(struct dma_fence *fence)
+#else
+static const char *mali_internal_fence_get_timeline_name(struct fence *fence)
+#endif
+{
+	struct mali_internal_sync_point *sync_pt;
+	struct mali_internal_sync_timeline *parent;
+
+	MALI_DEBUG_ASSERT_POINTER(fence);
+
+	sync_pt = mali_internal_fence_to_sync_pt(fence);
+	parent = mali_internal_sync_pt_to_sync_timeline(sync_pt);
+
+	return parent->name;
+}
+
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(4, 10, 0)
+static void mali_internal_fence_release(struct dma_fence *fence)
+#else
+static void mali_internal_fence_release(struct fence *fence)
+#endif
+{
+	unsigned long flags;
+	struct mali_internal_sync_point *sync_pt;
+	struct mali_internal_sync_timeline *parent;
+
+	MALI_DEBUG_ASSERT_POINTER(fence);
+
+	sync_pt = mali_internal_fence_to_sync_pt(fence);
+	parent = mali_internal_sync_pt_to_sync_timeline(sync_pt);
+
+
+	spin_lock_irqsave(fence->lock, flags);
+	if (WARN_ON_ONCE(!list_empty(&sync_pt->sync_pt_list)))
+		list_del(&sync_pt->sync_pt_list);
+	spin_unlock_irqrestore(fence->lock, flags);
+
+	if (parent->ops->free_pt)
+		parent->ops->free_pt(sync_pt);
+
+	kref_put(&parent->kref_count, mali_internal_sync_timeline_free);
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(4, 10, 0)
+	dma_fence_free(&sync_pt->base);
+#else
+	fence_free(&sync_pt->base);
+#endif
+}
+
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(4, 10, 0)
+static bool mali_internal_fence_signaled(struct dma_fence *fence)
+#else
+static bool mali_internal_fence_signaled(struct fence *fence)
+#endif
+{
+	int ret;
+	struct mali_internal_sync_point *sync_pt;
+	struct mali_internal_sync_timeline *parent;
+
+	MALI_DEBUG_ASSERT_POINTER(fence);
+
+	sync_pt = mali_internal_fence_to_sync_pt(fence);
+	parent = mali_internal_sync_pt_to_sync_timeline(sync_pt);
+
+	ret = parent->ops->has_signaled(sync_pt);
+	if (0 > ret)
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(4, 10, 0)
+		fence->error = ret;
+#else
+		fence->status = ret;
+#endif
+	return ret;
+}
+
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(4, 10, 0)
+static bool mali_internal_fence_enable_signaling(struct dma_fence *fence)
+#else
+static bool mali_internal_fence_enable_signaling(struct fence *fence)
+#endif
+{
+	struct mali_internal_sync_point *sync_pt;
+	struct mali_internal_sync_timeline *parent;
+
+	MALI_DEBUG_ASSERT_POINTER(fence);
+
+	sync_pt = mali_internal_fence_to_sync_pt(fence);
+	parent = mali_internal_sync_pt_to_sync_timeline(sync_pt);
+
+	if (mali_internal_fence_signaled(fence))
+		return false;
+
+	list_add_tail(&sync_pt->sync_pt_list, &parent->sync_pt_list_head);
+	return true;
+}
+
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(4, 10, 0)
+static void mali_internal_fence_value_str(struct dma_fence *fence, char *str, int size)
+#else
+static void mali_internal_fence_value_str(struct fence *fence, char *str, int size)
+#endif
+{
+	struct mali_internal_sync_point *sync_pt;
+	struct mali_internal_sync_timeline *parent;
+
+	MALI_DEBUG_ASSERT_POINTER(fence);
+	MALI_IGNORE(str);
+	MALI_IGNORE(size);
+
+	sync_pt = mali_internal_fence_to_sync_pt(fence);
+	parent = mali_internal_sync_pt_to_sync_timeline(sync_pt);
+
+	parent->ops->print_sync_pt(sync_pt);
+}
+
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(4, 10, 0)
+static const struct dma_fence_ops fence_ops = {
+#else
+static const struct fence_ops fence_ops = {
+#endif
+	.get_driver_name = mali_internal_fence_get_driver_name,
+	.get_timeline_name = mali_internal_fence_get_timeline_name,
+	.enable_signaling = mali_internal_fence_enable_signaling,
+	.signaled = mali_internal_fence_signaled,
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(4, 10, 0)
+	.wait = dma_fence_default_wait,
+#else
+	.wait = fence_default_wait,
+#endif
+	.release = mali_internal_fence_release,
+	.fence_value_str = mali_internal_fence_value_str,
+};
+#endif
diff -Naur driver/src/devicedrv/mali/linux/mali_internal_sync.h driver/src/devicedrv/mali/linux/mali_internal_sync.h
--- driver/src/devicedrv/mali/linux/mali_internal_sync.h	1970-01-01 08:00:00.000000000 +0800
+++ driver/src/devicedrv/mali/linux/mali_internal_sync.h	2017-09-04 10:16:02.234482575 +0800
@@ -0,0 +1,175 @@
+/*
+ * This confidential and proprietary software may be used only as
+ * authorised by a licensing agreement from ARM Limited
+ * (C) COPYRIGHT 2012-2015 ARM Limited
+ * ALL RIGHTS RESERVED
+ * The entire notice above must be reproduced on all authorised
+ * copies and copies may only be made to the extent permitted
+ * by a licensing agreement from ARM Limited.
+ */
+
+/**
+ * @file mali_internal_sync.h
+ *
+ * Mali internal structure/interface for sync.
+ */
+
+#ifndef _MALI_INTERNAL_SYNC_H
+#define _MALI_INTERNAL_SYNC_H
+#include <linux/version.h>
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(4, 6, 0)
+#include <linux/types.h>
+#include <linux/kref.h>
+#include <linux/list.h>
+#include <linux/spinlock.h>
+#include <linux/wait.h>
+#if LINUX_VERSION_CODE < KERNEL_VERSION(4, 7, 0)
+#include <sync.h>
+#else
+#include <linux/sync_file.h>
+#endif
+
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(4, 10, 0)
+#include <linux/dma-fence.h>
+#else
+#include <linux/fence.h>
+#endif
+
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(4, 9, 0)
+#if LINUX_VERSION_CODE < KERNEL_VERSION(4, 10, 0)
+#include <linux/fence-array.h>
+#else
+#include <linux/dma-fence-array.h>
+#endif
+#endif
+
+struct mali_internal_sync_timeline;
+struct mali_internal_sync_point;
+struct mali_internal_sync_fence;
+
+struct mali_internal_sync_timeline_ops {
+	const char *driver_name;
+	int (*has_signaled)(struct mali_internal_sync_point *pt);
+	void (*free_pt)(struct mali_internal_sync_point *sync_pt);
+	void (*release_obj)(struct mali_internal_sync_timeline *sync_timeline);
+	void (*print_sync_pt)(struct mali_internal_sync_point *sync_pt);
+};
+
+struct mali_internal_sync_timeline {
+	struct kref             kref_count;
+	const struct mali_internal_sync_timeline_ops  *ops;
+	char                    name[32];
+	bool                    destroyed;
+	int                     fence_context;
+	int                     value;
+	spinlock_t              sync_pt_list_lock;
+	struct list_head        sync_pt_list_head;
+};
+
+struct mali_internal_sync_point {
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(4, 10, 0)
+	struct dma_fence base;
+#else
+	struct fence base;
+#endif
+	struct list_head        sync_pt_list;
+};
+
+#if LINUX_VERSION_CODE < KERNEL_VERSION(4, 9, 0)
+struct mali_internal_sync_fence_cb {
+	struct fence_cb cb;
+	struct fence *fence;
+	struct mali_internal_sync_fence *sync_file;
+};
+#endif
+
+struct mali_internal_sync_fence {
+	struct file             *file;
+	struct kref             kref;
+	char		name[32];
+#ifdef CONFIG_DEBUG_FS
+	struct list_head	sync_file_list;
+#endif
+#if LINUX_VERSION_CODE < KERNEL_VERSION(4, 9, 0)
+	int num_fences;
+#endif
+	wait_queue_head_t       wq;
+#if LINUX_VERSION_CODE < KERNEL_VERSION(4, 9, 0)
+	atomic_t                status;
+	struct mali_internal_sync_fence_cb    cbs[];
+#elif LINUX_VERSION_CODE < KERNEL_VERSION(4, 10, 0)
+	struct fence *fence;
+	struct fence_cb cb;
+#else
+	struct dma_fence *fence;
+	struct dma_fence_cb cb;
+#endif
+};
+
+struct mali_internal_sync_fence_waiter;
+
+typedef void (*mali_internal_sync_callback_t)(struct mali_internal_sync_fence *sync_fence,
+		struct mali_internal_sync_fence_waiter *waiter);
+
+struct mali_internal_sync_fence_waiter {
+	wait_queue_t work;
+	mali_internal_sync_callback_t callback;
+};
+
+/**
+ * Create a mali internal sync timeline.
+ * @param ops The implementation ops for the mali internal sync timeline
+ * @param size The size to allocate
+ * @param name The sync_timeline name
+ * @return The new mali internal sync timeline if successful, NULL if not.
+ */
+struct mali_internal_sync_timeline *mali_internal_sync_timeline_create(const struct mali_internal_sync_timeline_ops *ops,
+		int size, const char *name);
+
+/**
+ * Destroy one mali internal sync timeline.
+ * @param sync_timeline The mali internal sync timeline to destroy.
+ */
+void mali_internal_sync_timeline_destroy(struct mali_internal_sync_timeline *sync_timeline);
+
+/**
+ * Signal one mali internal sync timeline.
+ * @param sync_timeline The mali internal sync timeline to signal.
+ */
+void mali_internal_sync_timeline_signal(struct mali_internal_sync_timeline *sync_timeline);
+
+/**
+ * Create one mali internal sync point.
+ * @param sync_timeline The mali internal sync timeline to add this mali internal sync point.
+  * @return the new mali internal sync point if successful, NULL if not.
+ */
+struct mali_internal_sync_point *mali_internal_sync_point_create(struct mali_internal_sync_timeline *sync_timeline, int size);
+
+/**
+ * Merge mali internal sync fences
+ * @param sync_fence1 The mali internal sync fence to merge
+ * @param sync_fence2 The mali internal sync fence to merge
+ * @return the new mali internal sync fence if successful, NULL if not.
+ */
+struct mali_internal_sync_fence *mali_internal_sync_fence_merge(struct mali_internal_sync_fence *sync_fence1,
+		struct mali_internal_sync_fence *sync_fence2);
+
+/**
+ * Get the mali internal sync fence from sync fd
+ * @param fd The sync handle to get the mali internal sync fence
+ * @return the mali internal sync fence if successful, NULL if not.
+ */
+struct mali_internal_sync_fence *mali_internal_sync_fence_fdget(int fd);
+
+
+void mali_internal_sync_fence_waiter_init(struct mali_internal_sync_fence_waiter *waiter,
+		mali_internal_sync_callback_t callback);
+
+int mali_internal_sync_fence_wait_async(struct mali_internal_sync_fence *sync_fence,
+					struct mali_internal_sync_fence_waiter *waiter);
+
+int mali_internal_sync_fence_cancel_async(struct mali_internal_sync_fence *sync_fence,
+		struct mali_internal_sync_fence_waiter *waiter);
+
+#endif /*LINUX_VERSION_CODE >= KERNEL_VERSION(4, 6, 0)*/
+#endif /* _MALI_INTERNAL_SYNC_H */
diff -Naur driver/src/devicedrv/mali/linux/mali_kernel_sysfs.c driver/src/devicedrv/mali/linux/mali_kernel_sysfs.c
--- driver/src/devicedrv/mali/linux/mali_kernel_sysfs.c	2017-01-20 14:42:04.000000000 +0800
+++ driver/src/devicedrv/mali/linux/mali_kernel_sysfs.c	2017-09-04 10:16:02.238482502 +0800
@@ -26,7 +26,12 @@
 
 #include <linux/seq_file.h>
 #include <linux/debugfs.h>
+#include <linux/version.h>
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(4,12,0)
+#include <linux/uaccess.h>
+#else
 #include <asm/uaccess.h>
+#endif
 #include <linux/module.h>
 #include <linux/mali/mali_utgard.h>
 #include "mali_kernel_sysfs.h"
diff -Naur driver/src/devicedrv/mali/linux/mali_linux_trace.h driver/src/devicedrv/mali/linux/mali_linux_trace.h
--- driver/src/devicedrv/mali/linux/mali_linux_trace.h	2017-01-20 14:42:05.000000000 +0800
+++ driver/src/devicedrv/mali/linux/mali_linux_trace.h	2017-04-27 18:55:11.000000000 +0800
@@ -1,7 +1,7 @@
 /*
  * This confidential and proprietary software may be used only as
  * authorised by a licensing agreement from ARM Limited
- * (C) COPYRIGHT 2012-2014, 2016-2017 ARM Limited
+ * (C) COPYRIGHT 2012-2014, 2017 ARM Limited
  * ALL RIGHTS RESERVED
  * The entire notice above must be reproduced on all authorised
  * copies and copies may only be made to the extent permitted
@@ -18,8 +18,9 @@
 
 #undef  TRACE_SYSTEM
 #define TRACE_SYSTEM mali
+#ifndef TRACEPOINTS_ENABLED
 #define TRACE_SYSTEM_STRING __stringfy(TRACE_SYSTEM)
-
+#endif
 #define TRACE_INCLUDE_PATH .
 #define TRACE_INCLUDE_FILE mali_linux_trace
 
diff -Naur driver/src/devicedrv/mali/linux/mali_memory.c driver/src/devicedrv/mali/linux/mali_memory.c
--- driver/src/devicedrv/mali/linux/mali_memory.c	2017-01-20 14:42:05.000000000 +0800
+++ driver/src/devicedrv/mali/linux/mali_memory.c	2017-09-04 10:16:02.238482502 +0800
@@ -53,26 +53,69 @@
 	/* If need to share the allocation, unref ref_count here */
 	mali_mem_allocation *alloc = (mali_mem_allocation *)vma->vm_private_data;
 
-	mali_allocation_unref(&alloc);
-	vma->vm_private_data = NULL;
+	if (NULL        != alloc) {
+		struct file *filp = NULL;
+		struct mali_session_data *session = NULL;
+
+		filp = vma->vm_file;
+		MALI_DEBUG_ASSERT(filp);
+		session = (struct mali_session_data *)filp->private_data;
+		MALI_DEBUG_ASSERT(session);
+
+		mali_session_memory_lock(session);
+		vma->vm_private_data = NULL;
+		mali_session_memory_unlock(session);
+
+		mali_allocation_unref(&alloc);
+	}
 }
 
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(4, 11, 0)
+static int mali_mem_vma_fault(struct vm_fault *vmf)
+#else
 static int mali_mem_vma_fault(struct vm_area_struct *vma, struct vm_fault *vmf)
+#endif
 {
-	mali_mem_allocation *alloc = (mali_mem_allocation *)vma->vm_private_data;
+	struct file *filp = NULL;
+	struct mali_session_data *session = NULL;
+	mali_mem_allocation *alloc = NULL;
 	mali_mem_backend *mem_bkend = NULL;
 	int ret;
 	int prefetch_num = MALI_VM_NUM_FAULT_PREFETCH;
-
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(4, 11, 0)
+	struct vm_area_struct *vma = vmf->vma;
+#endif
+
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(4, 10, 0)
+	unsigned long address = (unsigned long)vmf->address;
+#else
 	unsigned long address = (unsigned long)vmf->virtual_address;
-	MALI_DEBUG_ASSERT(alloc->backend_handle);
-	MALI_DEBUG_ASSERT((unsigned long)alloc->cpu_mapping.addr <= address);
+#endif
+	filp = vma->vm_file;
+	MALI_DEBUG_ASSERT(filp);
+	session = (struct mali_session_data *)filp->private_data;
+	MALI_DEBUG_ASSERT(session);
+	mali_session_memory_lock(session);
+	if (NULL == vma->vm_private_data) {
+		MALI_DEBUG_PRINT(1, ("mali_vma_fault: The memory has been freed!\n"));
+		mali_session_memory_unlock(session);
+		return VM_FAULT_SIGBUS;
+	} else {
+		alloc = (mali_mem_allocation *)vma->vm_private_data;
+		MALI_DEBUG_ASSERT(alloc->backend_handle);
+		MALI_DEBUG_ASSERT(alloc->cpu_mapping.vma == vma);
+		MALI_DEBUG_ASSERT((unsigned long)alloc->cpu_mapping.addr <= address);
+		mali_allocation_ref(alloc);
+	}
+	mali_session_memory_unlock(session);
+
 
 	/* Get backend memory & Map on CPU */
 	mutex_lock(&mali_idr_mutex);
 	if (!(mem_bkend = idr_find(&mali_backend_idr, alloc->backend_handle))) {
 		MALI_DEBUG_PRINT(1, ("Can't find memory backend in mmap!\n"));
 		mutex_unlock(&mali_idr_mutex);
+		mali_allocation_unref(&alloc);
 		return VM_FAULT_SIGBUS;
 	}
 	mutex_unlock(&mali_idr_mutex);
@@ -89,6 +132,7 @@
 		mutex_unlock(&mem_bkend->mutex);
 
 		if (ret != _MALI_OSK_ERR_OK) {
+			mali_allocation_unref(&alloc);
 			return VM_FAULT_OOM;
 		}
 		prefetch_num = 1;
@@ -101,6 +145,7 @@
 		mutex_unlock(&mem_bkend->mutex);
 
 		if (unlikely(ret != _MALI_OSK_ERR_OK)) {
+			mali_allocation_unref(&alloc);
 			return VM_FAULT_SIGBUS;
 		}
 	} else if ((mem_bkend->type == MALI_MEM_SWAP) ||
@@ -118,15 +163,20 @@
 
 		if (ret != _MALI_OSK_ERR_OK) {
 			MALI_DEBUG_PRINT(2, ("Mali swap memory page fault process failed, address=0x%x\n", address));
+			mali_allocation_unref(&alloc);
 			return VM_FAULT_OOM;
 		} else {
+			mali_allocation_unref(&alloc);
 			return VM_FAULT_LOCKED;
 		}
 	} else {
 		MALI_PRINT_ERROR(("Mali vma fault! It never happen, indicating some logic errors in caller.\n"));
+		mali_allocation_unref(&alloc);
 		/*NOT support yet or OOM*/
 		return VM_FAULT_OOM;
 	}
+
+	mali_allocation_unref(&alloc);
 	return VM_FAULT_NOPAGE;
 }
 
@@ -201,6 +251,11 @@
 	}
 	mutex_unlock(&mali_idr_mutex);
 
+	if ((vma->vm_start + mem_bkend->size) > vma->vm_end) {
+		MALI_PRINT_ERROR(("mali_mmap: out of memory mapping map_size %d, physical_size %d\n",  vma->vm_end - vma->vm_start, mem_bkend->size));
+		return -EFAULT;
+	}
+
 	if (!(MALI_MEM_SWAP == mali_alloc->type ||
 	      (MALI_MEM_COW == mali_alloc->type && (mem_bkend->flags & MALI_MEM_BACKEND_FLAG_SWAP_COWED)))) {
 		/* Set some bits which indicate that, the memory is IO memory, meaning
diff -Naur driver/src/devicedrv/mali/linux/mali_memory_dma_buf.c driver/src/devicedrv/mali/linux/mali_memory_dma_buf.c
--- driver/src/devicedrv/mali/linux/mali_memory_dma_buf.c	2017-01-20 14:42:05.000000000 +0800
+++ driver/src/devicedrv/mali/linux/mali_memory_dma_buf.c	2017-09-04 10:16:02.234482575 +0800
@@ -1,7 +1,7 @@
 /*
  * This confidential and proprietary software may be used only as
  * authorised by a licensing agreement from ARM Limited
- * (C) COPYRIGHT 2012-2017 ARM Limited
+ * (C) COPYRIGHT 2012-2016 ARM Limited
  * ALL RIGHTS RESERVED
  * The entire notice above must be reproduced on all authorised
  * copies and copies may only be made to the extent permitted
@@ -9,7 +9,12 @@
  */
 
 #include <linux/fs.h>      /* file system operations */
-#include <asm/uaccess.h>        /* user space access */
+#include <linux/version.h>
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(4,12,0)
+#include <linux/uaccess.h>
+#else
+#include <asm/uaccess.h>
+#endif
 #include <linux/dma-buf.h>
 #include <linux/scatterlist.h>
 #include <linux/rbtree.h>
@@ -40,7 +45,7 @@
 	struct mali_page_directory *pagedir;
 	_mali_osk_errcode_t err;
 	struct scatterlist *sg;
-	u32 virt, flags;
+	u32 virt, flags, unmap_dma_size;
 	int i;
 
 	MALI_DEBUG_ASSERT_POINTER(mem_backend);
@@ -50,7 +55,8 @@
 
 	mem = mem_backend->dma_buf.attachment;
 	MALI_DEBUG_ASSERT_POINTER(mem);
-
+	MALI_DEBUG_ASSERT_POINTER(mem->buf);
+	unmap_dma_size = mem->buf->size;
 	session = alloc->session;
 	MALI_DEBUG_ASSERT_POINTER(session);
 	MALI_DEBUG_ASSERT(mem->session == session);
@@ -62,9 +68,12 @@
 	mem->map_ref++;
 
 	MALI_DEBUG_PRINT(5, ("Mali DMA-buf: map attachment %p, new map_ref = %d\n", mem, mem->map_ref));
-
-	if (1 == mem->map_ref) {
-
+#if (!defined(CONFIG_MALI_DMA_BUF_MAP_ON_ATTACH)) && (defined(CONFIG_MALI_DMA_BUF_LAZY_MAP))
+	if (MALI_FALSE == mem->is_mapped)
+#else
+	if (1 == mem->map_ref)
+#endif
+	{
 		/* First reference taken, so we need to map the dma buf */
 		MALI_DEBUG_ASSERT(!mem->is_mapped);
 
@@ -91,6 +100,7 @@
 			u32 size = sg_dma_len(sg);
 			dma_addr_t phys = sg_dma_address(sg);
 
+			unmap_dma_size -= size;
 			/* sg must be page aligned. */
 			MALI_DEBUG_ASSERT(0 == size % MALI_MMU_PAGE_SIZE);
 			MALI_DEBUG_ASSERT(0 == (phys & ~(uintptr_t)0xFFFFFFFF));
@@ -109,9 +119,17 @@
 		}
 
 		mem->is_mapped = MALI_TRUE;
-		mali_session_memory_unlock(session);
+
+		if (0 != unmap_dma_size) {
+			MALI_DEBUG_PRINT_ERROR(("The dma buf size isn't equal to the total scatterlists' dma length.\n"));
+			mali_session_memory_unlock(session);
+			return -EFAULT;
+		}
+
 		/* Wake up any thread waiting for buffer to become mapped */
 		wake_up_all(&mem->wait_queue);
+
+		mali_session_memory_unlock(session);
 	} else {
 		MALI_DEBUG_ASSERT(mem->is_mapped);
 		mali_session_memory_unlock(session);
@@ -134,16 +152,21 @@
 	MALI_DEBUG_PRINT(5, ("Mali DMA-buf: unmap attachment %p, new map_ref = %d\n", mem, mem->map_ref));
 
 	if (0 == mem->map_ref) {
-		dma_buf_unmap_attachment(mem->attachment, mem->sgt, DMA_BIDIRECTIONAL);
+		if (NULL != mem->sgt) {
+			dma_buf_unmap_attachment(mem->attachment, mem->sgt, DMA_BIDIRECTIONAL);
+			 mem->sgt = NULL;
+		}
 		if (MALI_TRUE == mem->is_mapped) {
 			mali_mem_mali_map_free(alloc->session, alloc->psize, alloc->mali_vma_node.vm_node.start,
 					       alloc->flags);
 		}
 		mem->is_mapped = MALI_FALSE;
 	}
-	mali_session_memory_unlock(alloc->session);
+
 	/* Wake up any thread waiting for buffer to become unmapped */
 	wake_up_all(&mem->wait_queue);
+
+	mali_session_memory_unlock(alloc->session);
 }
 
 #if !defined(CONFIG_MALI_DMA_BUF_MAP_ON_ATTACH)
@@ -301,7 +324,11 @@
 
 	dma_mem->buf = buf;
 	dma_mem->session = session;
+#if (!defined(CONFIG_MALI_DMA_BUF_MAP_ON_ATTACH)) && (defined(CONFIG_MALI_DMA_BUF_LAZY_MAP))
+	dma_mem->map_ref = 1;
+#else
 	dma_mem->map_ref = 0;
+#endif
 	init_waitqueue_head(&dma_mem->wait_queue);
 
 	dma_mem->attachment = dma_buf_attach(dma_mem->buf, &mali_platform_device->dev);
@@ -344,17 +371,21 @@
 void mali_mem_unbind_dma_buf(mali_mem_backend *mem_backend)
 {
 	struct mali_dma_buf_attachment *mem;
+	struct  mali_session_data *session;
 	MALI_DEBUG_ASSERT_POINTER(mem_backend);
 	MALI_DEBUG_ASSERT(MALI_MEM_DMA_BUF == mem_backend->type);
 
 	mem = mem_backend->dma_buf.attachment;
+
 	MALI_DEBUG_ASSERT_POINTER(mem);
 	MALI_DEBUG_ASSERT_POINTER(mem->attachment);
 	MALI_DEBUG_ASSERT_POINTER(mem->buf);
 	MALI_DEBUG_PRINT(3, ("Mali DMA-buf: release attachment %p\n", mem));
 
-#if defined(CONFIG_MALI_DMA_BUF_MAP_ON_ATTACH)
 	MALI_DEBUG_ASSERT_POINTER(mem_backend->mali_allocation);
+	session = mem_backend->mali_allocation->session;
+
+#if (defined(CONFIG_MALI_DMA_BUF_MAP_ON_ATTACH)) ||((!defined(CONFIG_MALI_DMA_BUF_MAP_ON_ATTACH)) && (defined(CONFIG_MALI_DMA_BUF_LAZY_MAP)))
 	/* We mapped implicitly on attach, so we need to unmap on release */
 	mali_dma_buf_unmap(mem_backend->mali_allocation, mem);
 #endif
@@ -365,5 +396,8 @@
 	dma_buf_detach(mem->buf, mem->attachment);
 	dma_buf_put(mem->buf);
 
+	MALI_DEBUG_ASSERT_POINTER(session);
+	mali_session_memory_lock(session);
 	_mali_osk_free(mem);
+	mali_session_memory_unlock(session);
 }
diff -Naur driver/src/devicedrv/mali/linux/mali_memory_manager.c driver/src/devicedrv/mali/linux/mali_memory_manager.c
--- driver/src/devicedrv/mali/linux/mali_memory_manager.c	2017-01-20 14:42:04.000000000 +0800
+++ driver/src/devicedrv/mali/linux/mali_memory_manager.c	2017-09-04 10:16:02.234482575 +0800
@@ -409,6 +409,17 @@
 
 	MALI_DEBUG_PRINT(4, (" _mali_ukk_mem_allocate, vaddr=0x%x, size =0x%x! \n", args->gpu_vaddr, args->psize));
 
+	if (args->vsize < args->psize) {
+		MALI_PRINT_ERROR(("_mali_ukk_mem_allocate: vsize %d  shouldn't be less than psize %d\n", args->vsize, args->psize));
+		return _MALI_OSK_ERR_INVALID_ARGS;
+	} else if ((args->vsize % _MALI_OSK_MALI_PAGE_SIZE) || (args->psize % _MALI_OSK_MALI_PAGE_SIZE)) {
+		MALI_PRINT_ERROR(("_mali_ukk_mem_allocate: not supported non page aligned size-->pszie %d, vsize %d\n",  args->psize, args->vsize));
+		return _MALI_OSK_ERR_INVALID_ARGS;
+	} else if ((args->vsize != args->psize) && ((args->flags & _MALI_MEMORY_ALLOCATE_SWAPPABLE) || (args->flags & _MALI_MEMORY_ALLOCATE_SECURE))) {
+		MALI_PRINT_ERROR(("_mali_ukk_mem_allocate: not supported mem resizeable for mem flag %d\n",  args->flags));
+		return _MALI_OSK_ERR_INVALID_ARGS;
+	}
+
 	/* Check if the address is allocated
 	*/
 	mali_vma_node = mali_vma_offset_search(&session->allocation_mgr, args->gpu_vaddr, 0);
@@ -613,13 +624,18 @@
 		MALI_DEBUG_PRINT(1, ("_mali_ukk_mem_free: invalid addr: 0x%x\n", vaddr));
 		return _MALI_OSK_ERR_INVALID_ARGS;
 	}
-	MALI_DEBUG_ASSERT(NULL != mali_vma_node);
+
 	mali_alloc = container_of(mali_vma_node, struct mali_mem_allocation, mali_vma_node);
 
-	if (mali_alloc)
+	if (mali_alloc) {
+		if ((MALI_MEM_UMP == mali_alloc->type) || (MALI_MEM_DMA_BUF == mali_alloc->type)
+		    || (MALI_MEM_EXTERNAL == mali_alloc->type)) {
+			MALI_PRINT_ERROR(("_mali_ukk_mem_free: not supported for memory type %d\n",  mali_alloc->type));
+			return _MALI_OSK_ERR_UNSUPPORTED;
+		}
 		/* check ref_count */
 		args->free_pages_nr = mali_allocation_unref(&mali_alloc);
-
+	}
 	return _MALI_OSK_ERR_OK;
 }
 
@@ -771,9 +787,17 @@
 		return _MALI_OSK_ERR_INVALID_ARGS;
 	}
 
-	if (NULL != mali_allocation)
+	if (NULL != mali_allocation) {
+
+		if ((MALI_MEM_UMP != mali_allocation->type) && (MALI_MEM_DMA_BUF != mali_allocation->type)
+		    && (MALI_MEM_EXTERNAL != mali_allocation->type)) {
+			MALI_PRINT_ERROR(("_mali_ukk_mem_unbind not supported for memory type %d\n",  mali_allocation->type));
+			return _MALI_OSK_ERR_UNSUPPORTED;
+		}
+
 		/* check ref_count */
 		mali_allocation_unref(&mali_allocation);
+	}
 	return _MALI_OSK_ERR_OK;
 }
 
@@ -926,7 +950,10 @@
 		return ret;
 	}
 
-	MALI_DEBUG_ASSERT(MALI_MEM_COW  == mem_backend->type);
+	if (MALI_MEM_COW  != mem_backend->type) {
+		MALI_PRINT_ERROR(("_mali_ukk_mem_cow_modify_range: not supported for memory type %d !\n", mem_backend->type));
+		return _MALI_OSK_ERR_FAULT;
+	}
 
 	ret =  mali_memory_cow_modify_range(mem_backend, args->range_start, args->size);
 	args->change_pages_nr = mem_backend->cow_mem.change_pages_nr;
diff -Naur driver/src/devicedrv/mali/linux/mali_memory_os_alloc.c driver/src/devicedrv/mali/linux/mali_memory_os_alloc.c
--- driver/src/devicedrv/mali/linux/mali_memory_os_alloc.c	2017-01-20 14:42:05.000000000 +0800
+++ driver/src/devicedrv/mali/linux/mali_memory_os_alloc.c	2017-04-27 18:55:11.000000000 +0800
@@ -26,7 +26,9 @@
 #define MALI_OS_MEMORY_KERNEL_BUFFER_SIZE_IN_PAGES (MALI_OS_MEMORY_KERNEL_BUFFER_SIZE_IN_MB * 256)
 #define MALI_OS_MEMORY_POOL_TRIM_JIFFIES (10 * CONFIG_HZ) /* Default to 10s */
 
-#if LINUX_VERSION_CODE >= KERNEL_VERSION(3, 8, 0)
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(4, 8, 0)
+static unsigned long dma_attrs_wc= 0;
+#elif LINUX_VERSION_CODE >= KERNEL_VERSION(3, 8, 0)
 /* Write combine dma_attrs */
 static DEFINE_DMA_ATTRS(dma_attrs_wc);
 #endif
@@ -515,7 +517,11 @@
 	spin_unlock(&mali_mem_page_table_page_pool.lock);
 
 	if (_MALI_OSK_ERR_OK != ret) {
-#if LINUX_VERSION_CODE >= KERNEL_VERSION(3, 8, 0)
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(4, 8, 0)
+		*mapping = dma_alloc_attrs(&mali_platform_device->dev,
+					   _MALI_OSK_MALI_PAGE_SIZE, &tmp_phys,
+					   GFP_KERNEL, dma_attrs_wc);
+#elif LINUX_VERSION_CODE >= KERNEL_VERSION(3, 8, 0)
 		*mapping = dma_alloc_attrs(&mali_platform_device->dev,
 					   _MALI_OSK_MALI_PAGE_SIZE, &tmp_phys,
 					   GFP_KERNEL, &dma_attrs_wc);
@@ -554,7 +560,11 @@
 	} else {
 		spin_unlock(&mali_mem_page_table_page_pool.lock);
 
-#if LINUX_VERSION_CODE >= KERNEL_VERSION(3, 8, 0)
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(4, 8, 0)
+		dma_free_attrs(&mali_platform_device->dev,
+			     _MALI_OSK_MALI_PAGE_SIZE, virt, phys,
+			     dma_attrs_wc);
+#elif LINUX_VERSION_CODE >= KERNEL_VERSION(3, 8, 0)
 		dma_free_attrs(&mali_platform_device->dev,
 			       _MALI_OSK_MALI_PAGE_SIZE, virt, phys,
 			       &dma_attrs_wc);
@@ -610,7 +620,10 @@
 
 	/* After releasing the spinlock: free the pages we removed from the pool. */
 	for (i = 0; i < nr_to_free; i++) {
-#if LINUX_VERSION_CODE >= KERNEL_VERSION(3, 8, 0)
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(4, 8, 0)
+		dma_free_attrs(&mali_platform_device->dev, _MALI_OSK_MALI_PAGE_SIZE,
+		   	      virt_arr[i], (dma_addr_t)phys_arr[i], dma_attrs_wc);
+#elif LINUX_VERSION_CODE >= KERNEL_VERSION(3, 8, 0)
 		dma_free_attrs(&mali_platform_device->dev, _MALI_OSK_MALI_PAGE_SIZE,
 			       virt_arr[i], (dma_addr_t)phys_arr[i], &dma_attrs_wc);
 #else
@@ -760,8 +773,9 @@
 	if (NULL == mali_mem_os_allocator.wq) {
 		return _MALI_OSK_ERR_NOMEM;
 	}
-
-#if LINUX_VERSION_CODE >= KERNEL_VERSION(3, 8, 0)
+#if LINUX_VERSION_CODE >=  KERNEL_VERSION(4, 8, 0)
+	dma_attrs_wc = DMA_ATTR_WRITE_COMBINE;
+#elif LINUX_VERSION_CODE >= KERNEL_VERSION(3, 8, 0)
 	dma_set_attr(DMA_ATTR_WRITE_COMBINE, &dma_attrs_wc);
 #endif
 
diff -Naur driver/src/devicedrv/mali/linux/mali_memory_swap_alloc.c driver/src/devicedrv/mali/linux/mali_memory_swap_alloc.c
--- driver/src/devicedrv/mali/linux/mali_memory_swap_alloc.c	2017-01-20 14:42:04.000000000 +0800
+++ driver/src/devicedrv/mali/linux/mali_memory_swap_alloc.c	2017-04-27 18:55:11.000000000 +0800
@@ -1,7 +1,7 @@
 /*
  * This confidential and proprietary software may be used only as
  * authorised by a licensing agreement from ARM Limited
- * (C) COPYRIGHT 2013-2017 ARM Limited
+ * (C) COPYRIGHT 2013-2015, 2017 ARM Limited
  * ALL RIGHTS RESERVED
  * The entire notice above must be reproduced on all authorised
  * copies and copies may only be made to the extent permitted
@@ -52,7 +52,7 @@
 #define MALI_SWAP_LOW_MEM_DEFAULT_VALUE (60*1024*1024)
 #define MALI_SWAP_INVALIDATE_MALI_ADDRESS (0)               /* Used to mark the given memory cookie is invalidate. */
 #define MALI_SWAP_GLOBAL_SWAP_FILE_SIZE (0xFFFFFFFF)
-#define MALI_SWAP_GLOBAL_SWAP_FILE_INDEX ((MALI_SWAP_GLOBAL_SWAP_FILE_SIZE) >> PAGE_CACHE_SHIFT)
+#define MALI_SWAP_GLOBAL_SWAP_FILE_INDEX ((MALI_SWAP_GLOBAL_SWAP_FILE_SIZE) >> PAGE_SHIFT)
 #define MALI_SWAP_GLOBAL_SWAP_FILE_INDEX_RESERVE (1 << 15) /* Reserved for CoW nonlinear swap backend memory, the space size is 128MB. */
 
 unsigned int mali_mem_swap_out_threshold_value = MALI_SWAP_LOW_MEM_DEFAULT_VALUE;
@@ -183,7 +183,7 @@
 	dma_unmap_page(&mali_platform_device->dev, page_node->swap_it->dma_addr,
 		       _MALI_OSK_MALI_PAGE_SIZE, DMA_TO_DEVICE);
 	set_page_dirty(page_node->swap_it->page);
-	page_cache_release(page_node->swap_it->page);
+	put_page(page_node->swap_it->page);
 }
 
 void mali_mem_swap_unlock_single_mem_backend(mali_mem_backend *mem_bkend)
diff -Naur driver/src/devicedrv/mali/linux/mali_memory_util.c driver/src/devicedrv/mali/linux/mali_memory_util.c
--- driver/src/devicedrv/mali/linux/mali_memory_util.c	2017-01-20 14:42:04.000000000 +0800
+++ driver/src/devicedrv/mali/linux/mali_memory_util.c	2017-09-04 10:16:02.234482575 +0800
@@ -115,6 +115,9 @@
 		break;
 	}
 
+	if ((NULL != mali_alloc->cpu_mapping.vma) && (mali_alloc == (mali_alloc->cpu_mapping.vma)->vm_private_data))
+		(mali_alloc->cpu_mapping.vma)->vm_private_data = NULL;
+
 	/*Remove backend memory idex */
 	mutex_lock(&mali_idr_mutex);
 	idr_remove(&mali_backend_idr, mali_alloc->backend_handle);
diff -Naur driver/src/devicedrv/mali/linux/mali_osk_mali.c driver/src/devicedrv/mali/linux/mali_osk_mali.c
--- driver/src/devicedrv/mali/linux/mali_osk_mali.c	2017-01-20 14:42:05.000000000 +0800
+++ driver/src/devicedrv/mali/linux/mali_osk_mali.c	2017-09-04 10:16:02.230482648 +0800
@@ -13,7 +13,12 @@
  * Implementation of the OS abstraction layer which is specific for the Mali kernel device driver
  */
 #include <linux/kernel.h>
+#include <linux/version.h>
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(4,12,0)
+#include <linux/uaccess.h>
+#else
 #include <asm/uaccess.h>
+#endif
 #include <linux/platform_device.h>
 #include <linux/mali/mali_utgard.h>
 #include <linux/of.h>
diff -Naur driver/src/devicedrv/mali/linux/mali_osk_misc.c driver/src/devicedrv/mali/linux/mali_osk_misc.c
--- driver/src/devicedrv/mali/linux/mali_osk_misc.c	2017-01-20 14:42:05.000000000 +0800
+++ driver/src/devicedrv/mali/linux/mali_osk_misc.c	2017-09-04 10:16:02.230482648 +0800
@@ -13,7 +13,12 @@
  * Implementation of the OS abstraction layer for the kernel device driver
  */
 #include <linux/kernel.h>
+#include <linux/version.h>
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(4,12,0)
+#include <linux/uaccess.h>
+#else
 #include <asm/uaccess.h>
+#endif
 #include <asm/cacheflush.h>
 #include <linux/sched.h>
 #include <linux/seq_file.h>
diff -Naur driver/src/devicedrv/mali/linux/mali_osk_specific.h driver/src/devicedrv/mali/linux/mali_osk_specific.h
--- driver/src/devicedrv/mali/linux/mali_osk_specific.h	2017-01-20 14:42:05.000000000 +0800
+++ driver/src/devicedrv/mali/linux/mali_osk_specific.h	2017-09-04 10:16:02.230482648 +0800
@@ -17,7 +17,12 @@
 #ifndef __MALI_OSK_SPECIFIC_H__
 #define __MALI_OSK_SPECIFIC_H__
 
+#include <linux/version.h>
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(4,12,0)
+#include <linux/uaccess.h>
+#else
 #include <asm/uaccess.h>
+#endif
 #include <linux/platform_device.h>
 #include <linux/gfp.h>
 #include <linux/hardirq.h>
diff -Naur driver/src/devicedrv/mali/linux/mali_sync.c driver/src/devicedrv/mali/linux/mali_sync.c
--- driver/src/devicedrv/mali/linux/mali_sync.c	2017-01-20 14:42:05.000000000 +0800
+++ driver/src/devicedrv/mali/linux/mali_sync.c	2017-09-04 10:16:02.230482648 +0800
@@ -20,9 +20,17 @@
 #include <linux/module.h>
 
 struct mali_sync_pt {
+#if LINUX_VERSION_CODE < KERNEL_VERSION(4, 6, 0)
 	struct sync_pt         sync_pt;
+#else
+	struct mali_internal_sync_point         sync_pt;
+#endif
 	struct mali_sync_flag *flag;
+#if LINUX_VERSION_CODE < KERNEL_VERSION(4, 6, 0)
 	struct sync_timeline *sync_tl;  /**< Sync timeline this pt is connected to. */
+#else
+	struct mali_internal_sync_timeline *sync_tl;  /**< Sync timeline this pt is connected to. */
+#endif
 };
 
 /**
@@ -30,7 +38,11 @@
  * created from a sync flag, and when the flag is signaled, the sync fences will also be signaled.
  */
 struct mali_sync_flag {
+#if LINUX_VERSION_CODE < KERNEL_VERSION(4, 6, 0)
 	struct sync_timeline *sync_tl;  /**< Sync timeline this flag is connected to. */
+#else
+	struct mali_internal_sync_timeline *sync_tl;  /**< Sync timeline this flag is connected to. */
+#endif
 	u32                   point;    /**< Point on timeline. */
 	int                   status;   /**< 0 if unsignaled, 1 if signaled without error or negative if signaled with error. */
 	struct kref           refcount; /**< Reference count. */
@@ -41,41 +53,37 @@
  * When fence timeout can print more detailed mali timeline system info.
  */
 struct mali_sync_timeline_container {
+#if LINUX_VERSION_CODE < KERNEL_VERSION(4, 6, 0)
 	struct sync_timeline sync_timeline;
+#else
+	struct mali_internal_sync_timeline sync_timeline;
+#endif
 	struct mali_timeline *timeline;
 };
 
+#if LINUX_VERSION_CODE < KERNEL_VERSION(4, 6, 0)
 MALI_STATIC_INLINE struct mali_sync_pt *to_mali_sync_pt(struct sync_pt *pt)
+#else
+MALI_STATIC_INLINE struct mali_sync_pt *to_mali_sync_pt(struct mali_internal_sync_point *pt)
+#endif
 {
 	return container_of(pt, struct mali_sync_pt, sync_pt);
 }
 
+#if LINUX_VERSION_CODE < KERNEL_VERSION(4, 6, 0)
 MALI_STATIC_INLINE struct mali_sync_timeline_container *to_mali_sync_tl_container(struct sync_timeline *sync_tl)
+#else
+MALI_STATIC_INLINE struct mali_sync_timeline_container *to_mali_sync_tl_container(struct mali_internal_sync_timeline *sync_tl)
+#endif
 {
 	return container_of(sync_tl, struct mali_sync_timeline_container, sync_timeline);
 }
 
-static struct sync_pt *timeline_dup(struct sync_pt *pt)
-{
-	struct mali_sync_pt *mpt, *new_mpt;
-	struct sync_pt *new_pt;
-
-	MALI_DEBUG_ASSERT_POINTER(pt);
-	mpt = to_mali_sync_pt(pt);
-
-	new_pt = sync_pt_create(mpt->sync_tl, sizeof(struct mali_sync_pt));
-	if (NULL == new_pt) return NULL;
-
-	new_mpt = to_mali_sync_pt(new_pt);
-
-	mali_sync_flag_get(mpt->flag);
-	new_mpt->flag = mpt->flag;
-	new_mpt->sync_tl = mpt->sync_tl;
-
-	return new_pt;
-}
-
+#if LINUX_VERSION_CODE < KERNEL_VERSION(4, 6, 0)
 static int timeline_has_signaled(struct sync_pt *pt)
+#else
+static int timeline_has_signaled(struct mali_internal_sync_point *pt)
+#endif
 {
 	struct mali_sync_pt *mpt;
 
@@ -87,29 +95,11 @@
 	return mpt->flag->status;
 }
 
-static int timeline_compare(struct sync_pt *pta, struct sync_pt *ptb)
-{
-	struct mali_sync_pt *mpta;
-	struct mali_sync_pt *mptb;
-	u32 a, b;
-
-	MALI_DEBUG_ASSERT_POINTER(pta);
-	MALI_DEBUG_ASSERT_POINTER(ptb);
-	mpta = to_mali_sync_pt(pta);
-	mptb = to_mali_sync_pt(ptb);
-
-	MALI_DEBUG_ASSERT_POINTER(mpta->flag);
-	MALI_DEBUG_ASSERT_POINTER(mptb->flag);
-
-	a = mpta->flag->point;
-	b = mptb->flag->point;
-
-	if (a == b) return 0;
-
-	return ((b - a) < (a - b) ? -1 : 1);
-}
-
+#if LINUX_VERSION_CODE < KERNEL_VERSION(4, 6, 0)
 static void timeline_free_pt(struct sync_pt *pt)
+#else
+static void timeline_free_pt(struct mali_internal_sync_point *pt)
+#endif
 {
 	struct mali_sync_pt *mpt;
 
@@ -119,7 +109,11 @@
 	mali_sync_flag_put(mpt->flag);
 }
 
+#if LINUX_VERSION_CODE < KERNEL_VERSION(4, 6, 0)
 static void timeline_release(struct sync_timeline *sync_timeline)
+#else
+static void timeline_release(struct mali_internal_sync_timeline *sync_timeline)
+#endif
 {
 	struct mali_sync_timeline_container *mali_sync_tl = NULL;
 	struct mali_timeline *mali_tl = NULL;
@@ -142,6 +136,50 @@
 	module_put(THIS_MODULE);
 }
 
+#if LINUX_VERSION_CODE < KERNEL_VERSION(4, 6, 0)
+static struct sync_pt *timeline_dup(struct sync_pt *pt)
+{
+	struct mali_sync_pt *mpt, *new_mpt;
+	struct sync_pt *new_pt;
+	MALI_DEBUG_ASSERT_POINTER(pt);
+	
+	mpt = to_mali_sync_pt(pt);
+
+	new_pt = sync_pt_create(mpt->sync_tl, sizeof(struct mali_sync_pt));
+	if (NULL == new_pt) return NULL;
+
+	new_mpt = to_mali_sync_pt(new_pt);
+
+	mali_sync_flag_get(mpt->flag);
+	new_mpt->flag = mpt->flag;
+	new_mpt->sync_tl = mpt->sync_tl;
+
+	return new_pt;
+}
+
+static int timeline_compare(struct sync_pt *pta, struct sync_pt *ptb)
+{
+	struct mali_sync_pt *mpta;
+	struct mali_sync_pt *mptb;
+	u32 a, b;
+
+	MALI_DEBUG_ASSERT_POINTER(pta);
+	MALI_DEBUG_ASSERT_POINTER(ptb);
+	mpta = to_mali_sync_pt(pta);
+	mptb = to_mali_sync_pt(ptb);
+
+	MALI_DEBUG_ASSERT_POINTER(mpta->flag);
+	MALI_DEBUG_ASSERT_POINTER(mptb->flag);
+
+	a = mpta->flag->point;
+	b = mptb->flag->point;
+
+	if (a == b) return 0;
+
+	return ((b - a) < (a - b) ? -1 : 1);
+}
+#endif
+
 #if LINUX_VERSION_CODE < KERNEL_VERSION(3, 17, 0)
 static void timeline_print_pt(struct seq_file *s, struct sync_pt *sync_pt)
 {
@@ -198,7 +236,7 @@
 #endif
 	}
 }
-#else
+#elif LINUX_VERSION_CODE < KERNEL_VERSION(4, 6, 0)
 static void timeline_pt_value_str(struct sync_pt *pt, char *str, int size)
 {
 	struct mali_sync_pt *mpt;
@@ -254,9 +292,24 @@
 #endif
 	}
 }
-#endif
+#else
+static void timeline_print_sync_pt(struct mali_internal_sync_point *sync_pt)
+{
+	struct mali_sync_pt *mpt;
 
+	MALI_DEBUG_ASSERT_POINTER(sync_pt);
+
+	mpt = to_mali_sync_pt(sync_pt);
+
+	if (mpt->flag) {
+		MALI_DEBUG_PRINT(2, ("mali_internal_sync_pt: %u\n", mpt->flag->point));
+	} else {
+		MALI_DEBUG_PRINT(2, ("uninitialized\n", mpt->flag->point));
+	}
+}
+#endif
 
+#if LINUX_VERSION_CODE < KERNEL_VERSION(4, 6, 0)
 static struct sync_timeline_ops mali_timeline_ops = {
 	.driver_name    = "Mali",
 	.dup            = timeline_dup,
@@ -363,43 +416,145 @@
 	return flag;
 }
 
-void mali_sync_flag_get(struct mali_sync_flag *flag)
-{
-	MALI_DEBUG_ASSERT_POINTER(flag);
-	kref_get(&flag->refcount);
-}
-
 /**
- * Free sync flag.
+ * Create a sync point attached to given sync flag.
  *
- * @param ref kref object embedded in sync flag that should be freed.
+ * @note Sync points must be triggered in *exactly* the same order as they are created.
+ *
+ * @param flag Sync flag.
+ * @return New sync point if successful, NULL if not.
  */
-static void mali_sync_flag_free(struct kref *ref)
+static struct sync_pt *mali_sync_flag_create_pt(struct mali_sync_flag *flag)
 {
-	struct mali_sync_flag *flag;
+	struct sync_pt *pt;
+	struct mali_sync_pt *mpt;
 
-	MALI_DEBUG_ASSERT_POINTER(ref);
-	flag = container_of(ref, struct mali_sync_flag, refcount);
+	MALI_DEBUG_ASSERT_POINTER(flag);
+	MALI_DEBUG_ASSERT_POINTER(flag->sync_tl);
 
-	_mali_osk_free(flag);
+	pt = sync_pt_create(flag->sync_tl, sizeof(struct mali_sync_pt));
+	if (NULL == pt) return NULL;
+
+	mali_sync_flag_get(flag);
+
+	mpt = to_mali_sync_pt(pt);
+	mpt->flag = flag;
+	mpt->sync_tl = flag->sync_tl;
+
+	return pt;
 }
 
-void mali_sync_flag_put(struct mali_sync_flag *flag)
+struct sync_fence *mali_sync_flag_create_fence(struct mali_sync_flag *flag)
 {
+	struct sync_pt    *sync_pt;
+	struct sync_fence *sync_fence;
+
 	MALI_DEBUG_ASSERT_POINTER(flag);
-	kref_put(&flag->refcount, mali_sync_flag_free);
+	MALI_DEBUG_ASSERT_POINTER(flag->sync_tl);
+
+	sync_pt = mali_sync_flag_create_pt(flag);
+	if (NULL == sync_pt) return NULL;
+
+	sync_fence = sync_fence_create("mali_flag_fence", sync_pt);
+	if (NULL == sync_fence) {
+		sync_pt_free(sync_pt);
+		return NULL;
+	}
+
+	return sync_fence;
 }
+#else
+static struct mali_internal_sync_timeline_ops mali_timeline_ops = {
+	.driver_name    = "Mali",
+	.has_signaled   = timeline_has_signaled,
+	.free_pt        = timeline_free_pt,
+	.release_obj    = timeline_release,
+	.print_sync_pt = timeline_print_sync_pt,
+};
 
-void mali_sync_flag_signal(struct mali_sync_flag *flag, int error)
+struct mali_internal_sync_timeline *mali_sync_timeline_create(struct mali_timeline *timeline, const char *name)
 {
-	MALI_DEBUG_ASSERT_POINTER(flag);
+	struct mali_internal_sync_timeline *sync_tl;
+	struct mali_sync_timeline_container *mali_sync_tl;
 
-	MALI_DEBUG_ASSERT(0 == flag->status);
-	flag->status = (0 > error) ? error : 1;
+	sync_tl = mali_internal_sync_timeline_create(&mali_timeline_ops, sizeof(struct mali_sync_timeline_container), name);
+	if (NULL == sync_tl) return NULL;
 
-	_mali_osk_write_mem_barrier();
+	mali_sync_tl = to_mali_sync_tl_container(sync_tl);
+	mali_sync_tl->timeline = timeline;
 
-	sync_timeline_signal(flag->sync_tl);
+	/* Grab a reference on the module to ensure the callbacks are present
+	 * as long some timeline exists. The reference is released when the
+	 * timeline is freed.
+	 * Since this function is called from a ioctl on an open file we know
+	 * we already have a reference, so using __module_get is safe. */
+	__module_get(THIS_MODULE);
+
+	return sync_tl;
+}
+
+s32 mali_sync_fence_fd_alloc(struct mali_internal_sync_fence *sync_fence)
+{
+	s32 fd = -1;
+	
+	fd = get_unused_fd_flags(0);
+
+	if (fd < 0) {
+		fput(sync_fence->file);
+		return -1;
+	}
+	fd_install(fd, sync_fence->file);
+	return fd;
+}
+
+struct mali_internal_sync_fence *mali_sync_fence_merge(struct mali_internal_sync_fence *sync_fence1, struct mali_internal_sync_fence *sync_fence2)
+{
+	struct mali_internal_sync_fence *sync_fence;
+
+	MALI_DEBUG_ASSERT_POINTER(sync_fence1);
+	MALI_DEBUG_ASSERT_POINTER(sync_fence1);
+
+	sync_fence = mali_internal_sync_fence_merge(sync_fence1, sync_fence2);
+	fput(sync_fence1->file);
+	fput(sync_fence2->file);
+
+	return sync_fence;
+}
+
+struct mali_internal_sync_fence *mali_sync_timeline_create_signaled_fence(struct mali_internal_sync_timeline *sync_tl)
+{
+	struct mali_sync_flag *flag;
+	struct mali_internal_sync_fence *sync_fence;
+
+	MALI_DEBUG_ASSERT_POINTER(sync_tl);
+
+	flag = mali_sync_flag_create(sync_tl, 0);
+	if (NULL == flag) return NULL;
+
+	sync_fence = mali_sync_flag_create_fence(flag);
+
+	mali_sync_flag_signal(flag, 0);
+	mali_sync_flag_put(flag);
+
+	return sync_fence;
+}
+
+struct mali_sync_flag *mali_sync_flag_create(struct mali_internal_sync_timeline *sync_tl, mali_timeline_point point)
+{
+	struct mali_sync_flag *flag;
+
+	if (NULL == sync_tl) return NULL;
+
+	flag = _mali_osk_calloc(1, sizeof(*flag));
+	if (NULL == flag) return NULL;
+
+	flag->sync_tl = sync_tl;
+	flag->point = point;
+
+	flag->status = 0;
+	kref_init(&flag->refcount);
+
+	return flag;
 }
 
 /**
@@ -410,17 +565,20 @@
  * @param flag Sync flag.
  * @return New sync point if successful, NULL if not.
  */
-static struct sync_pt *mali_sync_flag_create_pt(struct mali_sync_flag *flag)
+static struct mali_internal_sync_point *mali_sync_flag_create_pt(struct mali_sync_flag *flag)
 {
-	struct sync_pt *pt;
+	struct mali_internal_sync_point *pt;
 	struct mali_sync_pt *mpt;
 
 	MALI_DEBUG_ASSERT_POINTER(flag);
 	MALI_DEBUG_ASSERT_POINTER(flag->sync_tl);
 
-	pt = sync_pt_create(flag->sync_tl, sizeof(struct mali_sync_pt));
-	if (NULL == pt) return NULL;
+	pt = mali_internal_sync_point_create(flag->sync_tl, sizeof(struct mali_sync_pt));
 
+	if (pt == NULL) {
+		MALI_PRINT_ERROR(("Mali sync: sync_pt creation failed\n"));
+		return NULL;
+	}
 	mali_sync_flag_get(flag);
 
 	mpt = to_mali_sync_pt(pt);
@@ -430,22 +588,74 @@
 	return pt;
 }
 
-struct sync_fence *mali_sync_flag_create_fence(struct mali_sync_flag *flag)
+struct mali_internal_sync_fence *mali_sync_flag_create_fence(struct mali_sync_flag *flag)
 {
-	struct sync_pt    *sync_pt;
-	struct sync_fence *sync_fence;
+	struct mali_internal_sync_point    *sync_pt;
+	struct mali_internal_sync_fence *sync_fence;
 
 	MALI_DEBUG_ASSERT_POINTER(flag);
 	MALI_DEBUG_ASSERT_POINTER(flag->sync_tl);
 
 	sync_pt = mali_sync_flag_create_pt(flag);
-	if (NULL == sync_pt) return NULL;
-
-	sync_fence = sync_fence_create("mali_flag_fence", sync_pt);
+	if (NULL == sync_pt) {
+		MALI_PRINT_ERROR(("Mali sync: sync_pt creation failed\n"));
+		return NULL;
+	}
+	sync_fence = (struct mali_internal_sync_fence *)sync_file_create(&sync_pt->base);
 	if (NULL == sync_fence) {
-		sync_pt_free(sync_pt);
+		MALI_PRINT_ERROR(("Mali sync: sync_fence creation failed\n"));
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(4, 10, 0)
+		dma_fence_put(&sync_pt->base);
+#else
+		fence_put(&sync_pt->base);
+#endif
 		return NULL;
 	}
 
 	return sync_fence;
 }
+#endif
+
+void mali_sync_flag_get(struct mali_sync_flag *flag)
+{
+	MALI_DEBUG_ASSERT_POINTER(flag);
+	kref_get(&flag->refcount);
+}
+
+/**
+ * Free sync flag.
+ *
+ * @param ref kref object embedded in sync flag that should be freed.
+ */
+static void mali_sync_flag_free(struct kref *ref)
+{
+	struct mali_sync_flag *flag;
+
+	MALI_DEBUG_ASSERT_POINTER(ref);
+	flag = container_of(ref, struct mali_sync_flag, refcount);
+
+	_mali_osk_free(flag);
+}
+
+void mali_sync_flag_put(struct mali_sync_flag *flag)
+{
+	MALI_DEBUG_ASSERT_POINTER(flag);
+	kref_put(&flag->refcount, mali_sync_flag_free);
+}
+
+void mali_sync_flag_signal(struct mali_sync_flag *flag, int error)
+{
+	MALI_DEBUG_ASSERT_POINTER(flag);
+
+	MALI_DEBUG_ASSERT(0 == flag->status);
+	flag->status = (0 > error) ? error : 1;
+
+	_mali_osk_write_mem_barrier();
+#if  LINUX_VERSION_CODE < KERNEL_VERSION(4, 6, 0)
+	sync_timeline_signal(flag->sync_tl);
+#else
+	mali_internal_sync_timeline_signal(flag->sync_tl);
+#endif
+}
+
+
diff -Naur driver/src/devicedrv/mali/linux/mali_sync.h driver/src/devicedrv/mali/linux/mali_sync.h
--- driver/src/devicedrv/mali/linux/mali_sync.h	2017-01-20 14:42:05.000000000 +0800
+++ driver/src/devicedrv/mali/linux/mali_sync.h	2017-04-27 18:55:11.000000000 +0800
@@ -1,7 +1,7 @@
 /*
  * This confidential and proprietary software may be used only as
  * authorised by a licensing agreement from ARM Limited
- * (C) COPYRIGHT 2012-2017 ARM Limited
+ * (C) COPYRIGHT 2012-2015, 2017 ARM Limited
  * ALL RIGHTS RESERVED
  * The entire notice above must be reproduced on all authorised
  * copies and copies may only be made to the extent permitted
@@ -17,14 +17,17 @@
 #ifndef _MALI_SYNC_H_
 #define _MALI_SYNC_H_
 
-#if defined(CONFIG_SYNC)
+#if defined(CONFIG_SYNC) || defined(CONFIG_SYNC_FILE)
 
 #include <linux/seq_file.h>
 #include <linux/version.h>
+
 #if LINUX_VERSION_CODE < KERNEL_VERSION(3, 10, 0)
 #include <linux/sync.h>
-#else
+#elif LINUX_VERSION_CODE < KERNEL_VERSION(4, 6, 0)
 #include <sync.h>
+#else
+#include "mali_internal_sync.h"
 #endif
 
 
@@ -33,6 +36,7 @@
 struct mali_sync_flag;
 struct mali_timeline;
 
+#if LINUX_VERSION_CODE < KERNEL_VERSION(4, 6, 0)
 /**
  * Create a sync timeline.
  *
@@ -67,6 +71,7 @@
  */
 struct sync_fence *mali_sync_timeline_create_signaled_fence(struct sync_timeline *sync_tl);
 
+
 /**
  * Create a sync flag.
  *
@@ -77,6 +82,67 @@
 struct mali_sync_flag *mali_sync_flag_create(struct sync_timeline *sync_tl, u32 point);
 
 /**
+ * Create a sync fence attached to given sync flag.
+ *
+ * @param flag Sync flag.
+ * @return New sync fence if successful, NULL if not.
+ */
+struct sync_fence *mali_sync_flag_create_fence(struct mali_sync_flag *flag);
+#else
+/**
+ * Create a sync timeline.
+ *
+ * @param name Name of the sync timeline.
+ * @return The new sync timeline if successful, NULL if not.
+ */
+struct mali_internal_sync_timeline *mali_sync_timeline_create(struct mali_timeline *timeline, const char *name);
+
+/**
+ * Creates a file descriptor representing the sync fence.  Will release sync fence if allocation of
+ * file descriptor fails.
+ *
+ * @param sync_fence Sync fence.
+ * @return File descriptor representing sync fence if successful, or -1 if not.
+ */
+s32 mali_sync_fence_fd_alloc(struct mali_internal_sync_fence *sync_fence);
+
+/**
+ * Merges two sync fences.  Both input sync fences will be released.
+ *
+ * @param sync_fence1 First sync fence.
+ * @param sync_fence2 Second sync fence.
+ * @return New sync fence that is the result of the merger if successful, or NULL if not.
+ */
+struct mali_internal_sync_fence *mali_sync_fence_merge(struct mali_internal_sync_fence *sync_fence1, struct mali_internal_sync_fence *sync_fence2);
+
+/**
+ * Create a sync fence that is already signaled.
+ *
+ * @param tl Sync timeline.
+ * @return New signaled sync fence if successful, NULL if not.
+ */
+struct mali_internal_sync_fence *mali_sync_timeline_create_signaled_fence(struct mali_internal_sync_timeline *sync_tl);
+
+
+/**
+ * Create a sync flag.
+ *
+ * @param sync_tl Sync timeline.
+ * @param point Point on Mali timeline.
+ * @return New sync flag if successful, NULL if not.
+ */
+struct mali_sync_flag *mali_sync_flag_create(struct mali_internal_sync_timeline *sync_tl, u32 point);
+
+/**
+ * Create a sync fence attached to given sync flag.
+ *
+ * @param flag Sync flag.
+ * @return New sync fence if successful, NULL if not.
+ */
+struct mali_internal_sync_fence *mali_sync_flag_create_fence(struct mali_sync_flag *flag);
+
+#endif
+/**
  * Grab sync flag reference.
  *
  * @param flag Sync flag.
@@ -98,14 +164,6 @@
  */
 void mali_sync_flag_signal(struct mali_sync_flag *flag, int error);
 
-/**
- * Create a sync fence attached to given sync flag.
- *
- * @param flag Sync flag.
- * @return New sync fence if successful, NULL if not.
- */
-struct sync_fence *mali_sync_flag_create_fence(struct mali_sync_flag *flag);
-
-#endif /* defined(CONFIG_SYNC) */
+#endif /* defined(CONFIG_SYNC) || defined(CONFIG_SYNC_FILE) */
 
 #endif /* _MALI_SYNC_H_ */
diff -Naur driver/src/devicedrv/mali/linux/mali_ukk_core.c driver/src/devicedrv/mali/linux/mali_ukk_core.c
--- driver/src/devicedrv/mali/linux/mali_ukk_core.c	2017-01-20 14:42:05.000000000 +0800
+++ driver/src/devicedrv/mali/linux/mali_ukk_core.c	2017-09-04 10:16:02.230482648 +0800
@@ -9,7 +9,12 @@
  */
 #include <linux/fs.h>       /* file system operations */
 #include <linux/slab.h>     /* memort allocation functions */
-#include <asm/uaccess.h>    /* user space access */
+#include <linux/version.h>
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(4,12,0)
+#include <linux/uaccess.h>
+#else
+#include <asm/uaccess.h>
+#endif
 
 #include "mali_ukk.h"
 #include "mali_osk.h"
diff -Naur driver/src/devicedrv/mali/linux/mali_ukk_gp.c driver/src/devicedrv/mali/linux/mali_ukk_gp.c
--- driver/src/devicedrv/mali/linux/mali_ukk_gp.c	2017-01-20 14:42:05.000000000 +0800
+++ driver/src/devicedrv/mali/linux/mali_ukk_gp.c	2017-09-04 10:16:02.230482648 +0800
@@ -8,7 +8,12 @@
  * by a licensing agreement from ARM Limited.
  */
 #include <linux/fs.h>       /* file system operations */
-#include <asm/uaccess.h>    /* user space access */
+#include <linux/version.h>
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(4,12,0)
+#include <linux/uaccess.h>
+#else
+#include <asm/uaccess.h>
+#endif
 
 #include "mali_ukk.h"
 #include "mali_osk.h"
diff -Naur driver/src/devicedrv/mali/linux/mali_ukk_mem.c driver/src/devicedrv/mali/linux/mali_ukk_mem.c
--- driver/src/devicedrv/mali/linux/mali_ukk_mem.c	2017-01-20 14:42:05.000000000 +0800
+++ driver/src/devicedrv/mali/linux/mali_ukk_mem.c	2017-09-04 10:16:02.234482575 +0800
@@ -8,7 +8,12 @@
  * by a licensing agreement from ARM Limited.
  */
 #include <linux/fs.h>       /* file system operations */
-#include <asm/uaccess.h>    /* user space access */
+#include <linux/version.h>
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(4,12,0)
+#include <linux/uaccess.h>
+#else
+#include <asm/uaccess.h>
+#endif
 
 #include "mali_ukk.h"
 #include "mali_osk.h"
diff -Naur driver/src/devicedrv/mali/linux/mali_ukk_pp.c driver/src/devicedrv/mali/linux/mali_ukk_pp.c
--- driver/src/devicedrv/mali/linux/mali_ukk_pp.c	2017-01-20 14:42:05.000000000 +0800
+++ driver/src/devicedrv/mali/linux/mali_ukk_pp.c	2017-09-04 10:16:02.230482648 +0800
@@ -8,7 +8,13 @@
  * by a licensing agreement from ARM Limited.
  */
 #include <linux/fs.h>       /* file system operations */
-#include <asm/uaccess.h>    /* user space access */
+#include <linux/version.h>
+
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(4,12,0)
+#include <linux/uaccess.h>
+#else
+#include <asm/uaccess.h>
+#endif
 
 #include "mali_ukk.h"
 #include "mali_osk.h"
diff -Naur driver/src/devicedrv/mali/linux/mali_ukk_profiling.c driver/src/devicedrv/mali/linux/mali_ukk_profiling.c
--- driver/src/devicedrv/mali/linux/mali_ukk_profiling.c	2017-01-20 14:42:04.000000000 +0800
+++ driver/src/devicedrv/mali/linux/mali_ukk_profiling.c	2017-09-04 10:16:02.230482648 +0800
@@ -8,7 +8,13 @@
  * by a licensing agreement from ARM Limited.
  */
 #include <linux/fs.h>       /* file system operations */
-#include <asm/uaccess.h>    /* user space access */
+#include <linux/version.h>
+
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(4,12,0)
+#include <linux/uaccess.h>
+#else
+#include <asm/uaccess.h>
+#endif
 #include <linux/slab.h>
 
 #include "mali_ukk.h"
diff -Naur driver/src/devicedrv/mali/linux/mali_ukk_soft_job.c driver/src/devicedrv/mali/linux/mali_ukk_soft_job.c
--- driver/src/devicedrv/mali/linux/mali_ukk_soft_job.c	2017-01-20 14:42:05.000000000 +0800
+++ driver/src/devicedrv/mali/linux/mali_ukk_soft_job.c	2017-09-04 10:16:02.230482648 +0800
@@ -8,7 +8,13 @@
  * by a licensing agreement from ARM Limited.
  */
 #include <linux/fs.h>       /* file system operations */
-#include <asm/uaccess.h>    /* user space access */
+#include <linux/version.h>
+
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(4,12,0)
+#include <linux/uaccess.h>
+#else
+#include <asm/uaccess.h>
+#endif
 
 #include "mali_ukk.h"
 #include "mali_osk.h"
diff -Naur driver/src/devicedrv/mali/linux/mali_ukk_timeline.c driver/src/devicedrv/mali/linux/mali_ukk_timeline.c
--- driver/src/devicedrv/mali/linux/mali_ukk_timeline.c	2017-01-20 14:42:05.000000000 +0800
+++ driver/src/devicedrv/mali/linux/mali_ukk_timeline.c	2017-09-04 10:16:02.230482648 +0800
@@ -1,14 +1,20 @@
 /*
  * This confidential and proprietary software may be used only as
  * authorised by a licensing agreement from ARM Limited
- * (C) COPYRIGHT 2013, 2016-2017 ARM Limited
+ * (C) COPYRIGHT 2013, 2017 ARM Limited
  * ALL RIGHTS RESERVED
  * The entire notice above must be reproduced on all authorised
  * copies and copies may only be made to the extent permitted
  * by a licensing agreement from ARM Limited.
  */
 #include <linux/fs.h>       /* file system operations */
-#include <asm/uaccess.h>    /* user space access */
+#include <linux/version.h>
+
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(4,12,0)
+#include <linux/uaccess.h>
+#else
+#include <asm/uaccess.h>
+#endif
 
 #include "mali_ukk.h"
 #include "mali_osk.h"
@@ -76,11 +82,11 @@
 	if (0 != copy_from_user(&uk_fence, &uargs->fence, sizeof(_mali_uk_fence_t))) return -EFAULT;
 	mali_timeline_fence_copy_uk_fence(&fence, &uk_fence);
 
-#if defined(CONFIG_SYNC)
+#if defined(CONFIG_SYNC) || defined(CONFIG_SYNC_FILE)
 	sync_fd = mali_timeline_sync_fence_create(session->timeline_system, &fence);
 #else
 	sync_fd = -1;
-#endif /* defined(CONFIG_SYNC) */
+#endif /* defined(CONFIG_SYNC) || defined(CONFIG_SYNC_FILE) */
 
 	if (0 != put_user(sync_fd, &uargs->sync_fd)) return -EFAULT;
 
diff -Naur driver/src/devicedrv/mali/linux/mali_ukk_vsync.c driver/src/devicedrv/mali/linux/mali_ukk_vsync.c
--- driver/src/devicedrv/mali/linux/mali_ukk_vsync.c	2017-01-20 14:42:04.000000000 +0800
+++ driver/src/devicedrv/mali/linux/mali_ukk_vsync.c	2017-09-04 10:16:02.230482648 +0800
@@ -8,7 +8,13 @@
  * by a licensing agreement from ARM Limited.
  */
 #include <linux/fs.h>       /* file system operations */
-#include <asm/uaccess.h>    /* user space access */
+#include <linux/version.h>
+
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(4,12,0)
+#include <linux/uaccess.h>
+#else
+#include <asm/uaccess.h>
+#endif
 
 #include "mali_ukk.h"
 #include "mali_osk.h"
diff -Naur driver/src/devicedrv/mali/Makefile driver/src/devicedrv/mali/Makefile
--- driver/src/devicedrv/mali/Makefile	2017-01-20 14:42:04.000000000 +0800
+++ driver/src/devicedrv/mali/Makefile	2017-09-04 09:56:59.000000000 +0800
@@ -15,6 +15,7 @@
 USING_DMA_BUF_FENCE ?= 0
 MALI_HEATMAPS_ENABLED ?= 0
 MALI_DMA_BUF_MAP_ON_ATTACH ?= 1
+MALI_DMA_BUF_LAZY_MAP ?= 0
 MALI_PMU_PARALLEL_POWER_UP ?= 0
 USING_DT ?= 0
 MALI_MEM_SWAP_TRACKING ?= 0
@@ -138,6 +139,15 @@
 export EXTRA_DEFINES += -DCONFIG_MALI_DMA_BUF_MAP_ON_ATTACH
 endif
 
+ifeq ($(MALI_DMA_BUF_LAZY_MAP),1)
+ifeq ($(MALI_DMA_BUF_MAP_ON_ATTACH),0)
+export CONFIG_MALI_DMA_BUF_LAZY_MAP=y
+export EXTRA_DEFINES += -DCONFIG_MALI_DMA_BUF_LAZY_MAP
+else
+$(warning "You want to enable MALI_DMA_BUF_LAZY_MAP but MALI_DMA_BUF_MAP_ON_ATTACH was enabled.")
+endif
+endif
+
 ifeq ($(MALI_SHARED_INTERRUPTS),1)
 export CONFIG_MALI_SHARED_INTERRUPTS=y
 export EXTRA_DEFINES += -DCONFIG_MALI_SHARED_INTERRUPTS
diff -Naur driver/src/devicedrv/ump/linux/ump_kernel_linux.c driver/src/devicedrv/ump/linux/ump_kernel_linux.c
--- driver/src/devicedrv/ump/linux/ump_kernel_linux.c	2017-01-20 14:42:04.000000000 +0800
+++ driver/src/devicedrv/ump/linux/ump_kernel_linux.c	2017-09-04 10:16:02.226482722 +0800
@@ -13,7 +13,13 @@
 #include <linux/cdev.h>              /* character device definitions */
 #include <linux/ioport.h>            /* request_mem_region */
 #include <linux/mm.h>                /* memory management functions and types */
-#include <asm/uaccess.h>             /* user space access */
+#include <linux/version.h>
+
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(4,12,0)
+#include <linux/uaccess.h>
+#else
+#include <asm/uaccess.h>
+#endif
 #include <asm/atomic.h>
 #include <linux/device.h>
 #include <linux/debugfs.h>
diff -Naur driver/src/devicedrv/ump/linux/ump_osk_low_level_mem.c driver/src/devicedrv/ump/linux/ump_osk_low_level_mem.c
--- driver/src/devicedrv/ump/linux/ump_osk_low_level_mem.c	2017-01-20 14:42:04.000000000 +0800
+++ driver/src/devicedrv/ump/linux/ump_osk_low_level_mem.c	2017-09-04 10:16:02.226482722 +0800
@@ -26,7 +26,11 @@
 #include <linux/slab.h>
 
 #include <asm/memory.h>
-#include <asm/uaccess.h>                        /* to verify pointers from user space */
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(4,12,0)
+#include <linux/uaccess.h>
+#else
+#include <asm/uaccess.h>
+#endif
 #include <asm/cacheflush.h>
 #include <linux/dma-mapping.h>
 
diff -Naur driver/src/devicedrv/ump/linux/ump_ukk_ref_wrappers.c driver/src/devicedrv/ump/linux/ump_ukk_ref_wrappers.c
--- driver/src/devicedrv/ump/linux/ump_ukk_ref_wrappers.c	2017-01-20 14:42:04.000000000 +0800
+++ driver/src/devicedrv/ump/linux/ump_ukk_ref_wrappers.c	2017-09-04 10:16:02.226482722 +0800
@@ -13,8 +13,12 @@
  * Defines the wrapper functions which turn Linux IOCTL calls into _ukk_ calls for the reference implementation
  */
 
-
-#include <asm/uaccess.h>             /* user space access */
+#include <linux/version.h>
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(4,12,0)
+#include <linux/uaccess.h>
+#else
+#include <asm/uaccess.h>
+#endif
 
 #include "ump_osk.h"
 #include "ump_uk_types.h"
diff -Naur driver/src/devicedrv/ump/linux/ump_ukk_wrappers.c driver/src/devicedrv/ump/linux/ump_ukk_wrappers.c
--- driver/src/devicedrv/ump/linux/ump_ukk_wrappers.c	2017-01-20 14:42:04.000000000 +0800
+++ driver/src/devicedrv/ump/linux/ump_ukk_wrappers.c	2017-09-04 10:16:02.226482722 +0800
@@ -12,8 +12,12 @@
  * @file ump_ukk_wrappers.c
  * Defines the wrapper functions which turn Linux IOCTL calls into _ukk_ calls
  */
-
-#include <asm/uaccess.h>             /* user space access */
+#include <linux/version.h>
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(4,12,0)
+#include <linux/uaccess.h>
+#else
+#include <asm/uaccess.h>
+#endif
 
 #include "ump_osk.h"
 #include "ump_uk_types.h"
